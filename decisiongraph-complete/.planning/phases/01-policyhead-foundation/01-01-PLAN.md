---
phase: 01-policyhead-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/decisiongraph/cell.py
  - src/decisiongraph/policyhead.py
  - tests/test_policyhead.py
autonomous: true

must_haves:
  truths:
    - "CellType.POLICY_HEAD exists as valid enum value"
    - "compute_policy_hash() returns deterministic SHA-256 hash"
    - "create_policy_head() returns valid DecisionCell with CellType.POLICY_HEAD"
    - "PolicyHead cell passes Chain.append() validation"
  artifacts:
    - path: "src/decisiongraph/cell.py"
      provides: "CellType.POLICY_HEAD enum value"
      contains: "POLICY_HEAD = \"policy_head\""
    - path: "src/decisiongraph/policyhead.py"
      provides: "PolicyHead creation and hashing functions"
      exports: ["compute_policy_hash", "create_policy_head"]
    - path: "tests/test_policyhead.py"
      provides: "PolicyHead unit tests"
      min_lines: 100
  key_links:
    - from: "src/decisiongraph/policyhead.py"
      to: "src/decisiongraph/cell.py"
      via: "imports CellType.POLICY_HEAD"
      pattern: "from.*cell.*import.*CellType"
    - from: "tests/test_policyhead.py"
      to: "src/decisiongraph/policyhead.py"
      via: "imports policyhead functions"
      pattern: "from.*policyhead.*import"
---

<objective>
Create the core PolicyHead infrastructure: CellType enum extension, deterministic policy_hash computation, and PolicyHead cell creation function.

Purpose: Establishes the foundation for immutable policy snapshots - PolicyHead cells that can be appended to the Chain like any other cell type.

Output: Working PolicyHead cell creation with deterministic hashing, ready for chain operations in Plan 02.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-policyhead-foundation/01-RESEARCH.md

@src/decisiongraph/cell.py
@src/decisiongraph/genesis.py
@src/decisiongraph/chain.py
@tests/test_core.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CellType.POLICY_HEAD enum and compute_policy_hash function</name>
  <files>src/decisiongraph/cell.py</files>
  <action>
1. Add POLICY_HEAD to CellType enum (after NAMESPACE_DEF):
   ```python
   POLICY_HEAD = "policy_head"  # v1.5: Immutable policy snapshot
   ```

2. Add compute_policy_hash function (after compute_content_id):
   ```python
   def compute_policy_hash(promoted_rule_ids: List[str]) -> str:
       """
       Compute deterministic policy_hash from promoted_rule_ids.

       Follows v1.3 canonicalization pattern:
       1. Sort rule IDs (deterministic ordering)
       2. JSON serialize with consistent separators
       3. SHA-256 hash

       Returns:
           64-character hex string (SHA-256 hash)
       """
       sorted_ids = sorted(promoted_rule_ids)
       # Use separators=(',', ':') for compact, deterministic JSON
       canonical_json = json.dumps(sorted_ids, separators=(',', ':'))
       return hashlib.sha256(canonical_json.encode('utf-8')).hexdigest()
   ```

3. Add 'compute_policy_hash' to __all__ exports list.

CRITICAL: The hash MUST be deterministic - same rule IDs in any order MUST produce same hash. ALWAYS sort before hashing.
  </action>
  <verify>
Run: `python -c "from decisiongraph.cell import CellType, compute_policy_hash; print(CellType.POLICY_HEAD); print(compute_policy_hash(['rule:b', 'rule:a']) == compute_policy_hash(['rule:a', 'rule:b']))"`
Expected: `policy_head` and `True`
  </verify>
  <done>
- CellType.POLICY_HEAD exists and equals "policy_head"
- compute_policy_hash() is exported and returns deterministic SHA-256 hash
- Different orderings of same rule IDs produce identical hash
  </done>
</task>

<task type="auto">
  <name>Task 2: Create policyhead.py module with create_policy_head function</name>
  <files>src/decisiongraph/policyhead.py</files>
  <action>
Create new file src/decisiongraph/policyhead.py with:

```python
"""
DecisionGraph Core: PolicyHead Module (v1.5)

PolicyHead cells are immutable policy snapshots that track which rules
are promoted (active policy) at any point in time.

Key properties:
- PolicyHead is a specialized DecisionCell with CellType.POLICY_HEAD
- Stored in main Chain (uses existing append-only infrastructure)
- policy_hash is SHA-256 of sorted promoted_rule_ids (deterministic)
- prev_policy_head links PolicyHead cells for a namespace (chain within chain)
- fact.object contains JSON-serialized policy data

This enables bitemporal "what policy was active when?" queries.
"""

import json
from typing import List, Optional

from .cell import (
    DecisionCell,
    Header,
    Fact,
    LogicAnchor,
    Proof,
    CellType,
    SourceQuality,
    compute_policy_hash,
    compute_rule_logic_hash,
    get_current_timestamp,
    validate_namespace
)


# The policy promotion rule - embedded in the system
POLICY_PROMOTION_RULE = """
-- DecisionGraph Policy Promotion Rule v1.5
-- This rule defines the creation of a PolicyHead cell
-- that captures the promoted rules for a namespace

CREATE POLICY_HEAD:
  WHEN promotion_finalized
  THEN create_policy_head_cell
  WITH cell_type = "policy_head"
  AND namespace = target_namespace
  AND policy_hash = sha256(sorted(promoted_rule_ids))
  AND prev_policy_head = current_policy_head_id or None
  AND subject = "policy:head"
  AND predicate = "policy_snapshot"
  AND confidence = 1.0
  AND source_quality = "verified"
"""

POLICY_PROMOTION_RULE_HASH = compute_rule_logic_hash(POLICY_PROMOTION_RULE)

# Schema version for PolicyHead cells
POLICYHEAD_SCHEMA_VERSION = "1.5"


def create_policy_head(
    namespace: str,
    promoted_rule_ids: List[str],
    graph_id: str,
    prev_cell_hash: str,
    prev_policy_head: Optional[str] = None,
    system_time: Optional[str] = None,
    creator: Optional[str] = None,
    bootstrap_mode: bool = True
) -> DecisionCell:
    """
    Create a PolicyHead cell for a namespace.

    PolicyHead captures the current promoted rules (active policy) for a namespace.
    It is a specialized DecisionCell that links via prev_policy_head to form
    a policy chain within the main Chain.

    Args:
        namespace: Target namespace for this policy (e.g., "corp.hr")
        promoted_rule_ids: List of rule IDs that are promoted (active)
        graph_id: Graph ID (must match chain's graph_id)
        prev_cell_hash: Hash of the previous cell in the main Chain
        prev_policy_head: Cell ID of previous PolicyHead for this namespace (None for first)
        system_time: Optional timestamp (defaults to now, must be ISO 8601 UTC)
        creator: Optional identifier of who created this PolicyHead
        bootstrap_mode: If True, signature is not required

    Returns:
        DecisionCell with CellType.POLICY_HEAD

    Raises:
        ValueError: If namespace is invalid

    Example:
        >>> policy_head = create_policy_head(
        ...     namespace="corp.hr",
        ...     promoted_rule_ids=["rule:salary_v2", "rule:benefits_v1"],
        ...     graph_id=chain.graph_id,
        ...     prev_cell_hash=chain.head.cell_id
        ... )
    """
    # Validate namespace
    if not validate_namespace(namespace):
        raise ValueError(
            f"Invalid namespace format: '{namespace}'. "
            f"Must be lowercase alphanumeric/underscore segments separated by dots."
        )

    # Compute deterministic policy_hash
    policy_hash = compute_policy_hash(promoted_rule_ids)
    sorted_rule_ids = sorted(promoted_rule_ids)

    # Use provided system_time or current time
    ts = system_time or get_current_timestamp()

    # Policy data as JSON in fact.object
    policy_data = {
        "policy_hash": policy_hash,
        "promoted_rule_ids": sorted_rule_ids,
        "prev_policy_head": prev_policy_head  # None for first PolicyHead in namespace
    }

    # Create the PolicyHead header
    header = Header(
        version=POLICYHEAD_SCHEMA_VERSION,
        graph_id=graph_id,
        cell_type=CellType.POLICY_HEAD,
        system_time=ts,
        prev_cell_hash=prev_cell_hash
    )

    # Create the PolicyHead fact
    fact = Fact(
        namespace=namespace,
        subject="policy:head",
        predicate="policy_snapshot",
        object=json.dumps(policy_data, sort_keys=True),
        confidence=1.0,
        source_quality=SourceQuality.VERIFIED,
        valid_from=ts,
        valid_to=None  # PolicyHead is point-in-time snapshot
    )

    # Create the Logic Anchor
    logic_anchor = LogicAnchor(
        rule_id="system:policy_promotion_v1.5",
        rule_logic_hash=POLICY_PROMOTION_RULE_HASH,
        interpreter="system:v1.5"
    )

    # Create the proof
    proof = Proof(
        signer_id=creator or "system:policy",
        signer_key_id=None,
        signature=None,
        merkle_root=None,
        signature_required=not bootstrap_mode
    )

    # Create and return the PolicyHead cell
    return DecisionCell(
        header=header,
        fact=fact,
        logic_anchor=logic_anchor,
        evidence=[],
        proof=proof
    )


def parse_policy_data(policy_head: DecisionCell) -> dict:
    """
    Parse policy data from a PolicyHead cell's fact.object.

    Args:
        policy_head: A DecisionCell with CellType.POLICY_HEAD

    Returns:
        Dict with keys: policy_hash, promoted_rule_ids, prev_policy_head

    Raises:
        ValueError: If cell is not a PolicyHead or data is malformed
    """
    if policy_head.header.cell_type != CellType.POLICY_HEAD:
        raise ValueError(
            f"Expected POLICY_HEAD cell, got {policy_head.header.cell_type.value}"
        )

    try:
        return json.loads(policy_head.fact.object)
    except json.JSONDecodeError as e:
        raise ValueError(f"Malformed policy data in PolicyHead: {e}")


def verify_policy_hash(policy_head: DecisionCell) -> bool:
    """
    Verify that a PolicyHead's policy_hash matches its promoted_rule_ids.

    This is a tamper-detection check: if someone modified the promoted_rule_ids
    without updating policy_hash, this will return False.

    Args:
        policy_head: A DecisionCell with CellType.POLICY_HEAD

    Returns:
        True if policy_hash is valid, False if tampered
    """
    policy_data = parse_policy_data(policy_head)
    expected_hash = compute_policy_hash(policy_data["promoted_rule_ids"])
    return policy_data["policy_hash"] == expected_hash


# Export public interface
__all__ = [
    # Creation
    'create_policy_head',

    # Parsing/verification
    'parse_policy_data',
    'verify_policy_hash',

    # Constants
    'POLICY_PROMOTION_RULE',
    'POLICY_PROMOTION_RULE_HASH',
    'POLICYHEAD_SCHEMA_VERSION'
]
```

IMPORTANT: Use existing cell.py patterns (Header, Fact, LogicAnchor). PolicyHead is NOT a new class - it's a DecisionCell with specific structure.
  </action>
  <verify>
Run: `python -c "from decisiongraph.policyhead import create_policy_head, POLICY_PROMOTION_RULE_HASH; print('Hash:', POLICY_PROMOTION_RULE_HASH[:16])"`
Expected: Non-empty hash prefix printed without errors.
  </verify>
  <done>
- policyhead.py module exists with create_policy_head function
- create_policy_head returns DecisionCell with CellType.POLICY_HEAD
- Policy data (hash, rule_ids, prev_policy_head) stored in fact.object as JSON
- parse_policy_data and verify_policy_hash helper functions exist
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive PolicyHead tests</name>
  <files>tests/test_policyhead.py</files>
  <action>
Create new file tests/test_policyhead.py with comprehensive tests:

```python
"""
DecisionGraph: PolicyHead Test Suite (v1.5)

Tests for:
1. CellType.POLICY_HEAD enum value
2. compute_policy_hash determinism
3. create_policy_head cell creation
4. PolicyHead integration with Chain.append()
5. Policy data parsing and verification

Requirements covered:
- POL-01: Create PolicyHead cell structure
- POL-02: Deterministic policy_hash computation
"""

import pytest
import json
import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

from decisiongraph import (
    DecisionCell,
    CellType,
    SourceQuality,
    Chain,
    create_chain,
    compute_policy_hash
)

from decisiongraph.policyhead import (
    create_policy_head,
    parse_policy_data,
    verify_policy_hash,
    POLICY_PROMOTION_RULE_HASH,
    POLICYHEAD_SCHEMA_VERSION
)

# Import test time constants
from test_utils import T0, T1, T2


class TestCellTypePolicyHead:
    """Tests for CellType.POLICY_HEAD enum (POL-01)"""

    def test_policy_head_enum_exists(self):
        """CellType.POLICY_HEAD should exist"""
        assert hasattr(CellType, 'POLICY_HEAD')
        assert CellType.POLICY_HEAD.value == "policy_head"

    def test_policy_head_is_valid_cell_type(self):
        """POLICY_HEAD should be usable like other CellTypes"""
        # Should be iterable with other types
        all_types = list(CellType)
        assert CellType.POLICY_HEAD in all_types

        # Should be comparable
        assert CellType.POLICY_HEAD != CellType.GENESIS
        assert CellType.POLICY_HEAD != CellType.FACT


class TestComputePolicyHash:
    """Tests for compute_policy_hash determinism (POL-02)"""

    def test_empty_list_produces_hash(self):
        """Empty promoted_rule_ids should produce valid hash"""
        hash_result = compute_policy_hash([])
        assert len(hash_result) == 64  # SHA-256 hex
        assert all(c in '0123456789abcdef' for c in hash_result)

    def test_single_rule_produces_hash(self):
        """Single rule ID should produce valid hash"""
        hash_result = compute_policy_hash(["rule:salary_v1"])
        assert len(hash_result) == 64

    def test_same_rules_same_hash(self):
        """Same rules should always produce same hash"""
        rules = ["rule:a", "rule:b", "rule:c"]
        hash1 = compute_policy_hash(rules)
        hash2 = compute_policy_hash(rules)
        assert hash1 == hash2

    def test_order_independent_hash(self):
        """Different orderings of same rules MUST produce same hash"""
        rules_abc = ["rule:a", "rule:b", "rule:c"]
        rules_cba = ["rule:c", "rule:b", "rule:a"]
        rules_bac = ["rule:b", "rule:a", "rule:c"]

        hash_abc = compute_policy_hash(rules_abc)
        hash_cba = compute_policy_hash(rules_cba)
        hash_bac = compute_policy_hash(rules_bac)

        assert hash_abc == hash_cba == hash_bac

    def test_different_rules_different_hash(self):
        """Different rules should produce different hashes"""
        hash1 = compute_policy_hash(["rule:a"])
        hash2 = compute_policy_hash(["rule:b"])
        assert hash1 != hash2

    def test_subset_different_hash(self):
        """Subset of rules should produce different hash"""
        hash_full = compute_policy_hash(["rule:a", "rule:b"])
        hash_subset = compute_policy_hash(["rule:a"])
        assert hash_full != hash_subset

    def test_hash_is_sha256(self):
        """Hash should be valid SHA-256 (64 hex chars)"""
        import hashlib
        rules = ["rule:test"]
        hash_result = compute_policy_hash(rules)

        # Manual verification
        sorted_rules = sorted(rules)
        canonical = json.dumps(sorted_rules, separators=(',', ':'))
        expected = hashlib.sha256(canonical.encode('utf-8')).hexdigest()

        assert hash_result == expected


class TestCreatePolicyHead:
    """Tests for create_policy_head function (POL-01)"""

    @pytest.fixture
    def test_chain(self):
        """Create a test chain with Genesis"""
        return create_chain(
            graph_name="TestGraph",
            root_namespace="corp",
            system_time=T0
        )

    def test_creates_valid_cell(self, test_chain):
        """create_policy_head should return valid DecisionCell"""
        policy_head = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:salary_v1"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )

        assert isinstance(policy_head, DecisionCell)
        assert policy_head.verify_integrity()

    def test_cell_type_is_policy_head(self, test_chain):
        """Cell type should be POLICY_HEAD"""
        policy_head = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:test"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )

        assert policy_head.header.cell_type == CellType.POLICY_HEAD

    def test_schema_version_is_1_5(self, test_chain):
        """Schema version should be 1.5"""
        policy_head = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:test"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )

        assert policy_head.header.version == "1.5"

    def test_fact_structure(self, test_chain):
        """Fact should have correct structure"""
        policy_head = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:test"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )

        assert policy_head.fact.namespace == "corp.hr"
        assert policy_head.fact.subject == "policy:head"
        assert policy_head.fact.predicate == "policy_snapshot"
        assert policy_head.fact.confidence == 1.0
        assert policy_head.fact.source_quality == SourceQuality.VERIFIED

    def test_policy_data_in_fact_object(self, test_chain):
        """Policy data should be JSON in fact.object"""
        rules = ["rule:b", "rule:a"]  # Unsorted input
        policy_head = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=rules,
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            prev_policy_head="prev_head_id",
            system_time=T1
        )

        policy_data = json.loads(policy_head.fact.object)

        assert "policy_hash" in policy_data
        assert "promoted_rule_ids" in policy_data
        assert "prev_policy_head" in policy_data

        # Rules should be sorted in stored data
        assert policy_data["promoted_rule_ids"] == ["rule:a", "rule:b"]
        assert policy_data["prev_policy_head"] == "prev_head_id"

    def test_first_policy_head_has_null_prev(self, test_chain):
        """First PolicyHead in namespace should have prev_policy_head=None"""
        policy_head = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:test"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )

        policy_data = json.loads(policy_head.fact.object)
        assert policy_data["prev_policy_head"] is None

    def test_logic_anchor_correct(self, test_chain):
        """Logic anchor should reference policy promotion rule"""
        policy_head = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:test"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )

        assert policy_head.logic_anchor.rule_id == "system:policy_promotion_v1.5"
        assert policy_head.logic_anchor.rule_logic_hash == POLICY_PROMOTION_RULE_HASH
        assert policy_head.logic_anchor.interpreter == "system:v1.5"

    def test_invalid_namespace_raises(self, test_chain):
        """Invalid namespace should raise ValueError"""
        with pytest.raises(ValueError, match="Invalid namespace"):
            create_policy_head(
                namespace="INVALID",  # Uppercase not allowed
                promoted_rule_ids=["rule:test"],
                graph_id=test_chain.graph_id,
                prev_cell_hash=test_chain.head.cell_id,
                system_time=T1
            )

    def test_empty_rules_allowed(self, test_chain):
        """Empty promoted_rule_ids should be allowed (policy with no rules)"""
        policy_head = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=[],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )

        policy_data = json.loads(policy_head.fact.object)
        assert policy_data["promoted_rule_ids"] == []


class TestPolicyHeadChainIntegration:
    """Tests for PolicyHead integration with Chain"""

    @pytest.fixture
    def test_chain(self):
        """Create a test chain with Genesis"""
        return create_chain(
            graph_name="TestGraph",
            root_namespace="corp",
            system_time=T0
        )

    def test_append_policy_head_to_chain(self, test_chain):
        """PolicyHead should be appendable to Chain"""
        policy_head = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:test"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )

        # Should not raise
        test_chain.append(policy_head)

        assert test_chain.length == 2
        assert test_chain.head == policy_head

    def test_find_policy_heads_by_type(self, test_chain):
        """Chain.find_by_type should find PolicyHead cells"""
        policy_head = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:test"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )
        test_chain.append(policy_head)

        found = test_chain.find_by_type(CellType.POLICY_HEAD)

        assert len(found) == 1
        assert found[0] == policy_head

    def test_multiple_policy_heads_same_namespace(self, test_chain):
        """Multiple PolicyHeads for same namespace should be appendable"""
        ph1 = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v1"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )
        test_chain.append(ph1)

        ph2 = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v1", "rule:v2"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            prev_policy_head=ph1.cell_id,
            system_time=T2
        )
        test_chain.append(ph2)

        found = test_chain.find_by_type(CellType.POLICY_HEAD)
        assert len(found) == 2


class TestParsePolicyData:
    """Tests for parse_policy_data helper"""

    @pytest.fixture
    def test_chain(self):
        return create_chain(
            graph_name="TestGraph",
            root_namespace="corp",
            system_time=T0
        )

    def test_parse_valid_policy_head(self, test_chain):
        """parse_policy_data should extract policy data"""
        policy_head = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:a", "rule:b"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            prev_policy_head="prev_id",
            system_time=T1
        )

        data = parse_policy_data(policy_head)

        assert data["promoted_rule_ids"] == ["rule:a", "rule:b"]
        assert data["prev_policy_head"] == "prev_id"
        assert "policy_hash" in data


class TestVerifyPolicyHash:
    """Tests for verify_policy_hash helper"""

    @pytest.fixture
    def test_chain(self):
        return create_chain(
            graph_name="TestGraph",
            root_namespace="corp",
            system_time=T0
        )

    def test_valid_policy_head_verifies(self, test_chain):
        """verify_policy_hash should return True for valid PolicyHead"""
        policy_head = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:a", "rule:b"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )

        assert verify_policy_hash(policy_head) is True


class TestExistingTestsStillPass:
    """Verify that existing tests are not broken"""

    def test_genesis_still_works(self):
        """Genesis creation should still work"""
        chain = create_chain(
            graph_name="TestGraph",
            root_namespace="corp",
            system_time=T0
        )

        assert chain.has_genesis()
        assert chain.genesis.header.cell_type == CellType.GENESIS

    def test_other_cell_types_unchanged(self):
        """Other CellType values should be unchanged"""
        assert CellType.GENESIS.value == "genesis"
        assert CellType.FACT.value == "fact"
        assert CellType.RULE.value == "rule"
        assert CellType.DECISION.value == "decision"
```

CRITICAL: Import test_utils for deterministic timestamps (T0, T1, T2). Do NOT use datetime.now() or get_current_timestamp() in tests.
  </action>
  <verify>
Run: `cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_policyhead.py -v`
Expected: All tests pass (20+ tests).
  </verify>
  <done>
- tests/test_policyhead.py exists with 20+ test cases
- Tests cover POL-01 (CellType, cell structure) and POL-02 (deterministic hash)
- All new tests pass
- Existing tests still pass (run `pytest tests/test_core.py` to verify)
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. All new tests pass:
   ```bash
   python -m pytest tests/test_policyhead.py -v
   ```

2. All existing tests still pass (517 tests):
   ```bash
   python -m pytest tests/ -v --tb=short
   ```

3. Quick integration check:
   ```python
   from decisiongraph import create_chain, CellType, compute_policy_hash
   from decisiongraph.policyhead import create_policy_head

   chain = create_chain("Test", "corp")
   ph = create_policy_head(
       namespace="corp.hr",
       promoted_rule_ids=["rule:x"],
       graph_id=chain.graph_id,
       prev_cell_hash=chain.head.cell_id
   )
   chain.append(ph)
   print(f"PolicyHead appended: {ph.cell_id[:16]}...")
   ```
</verification>

<success_criteria>
- CellType.POLICY_HEAD exists as valid enum value
- compute_policy_hash() returns deterministic SHA-256 hash (order-independent)
- create_policy_head() returns valid DecisionCell with POLICY_HEAD type
- PolicyHead cell passes Chain.append() validation
- All 517 existing tests still pass
- New test_policyhead.py has 20+ passing tests
</success_criteria>

<output>
After completion, create `.planning/phases/01-policyhead-foundation/01-01-SUMMARY.md`
</output>
