---
phase: 01-policyhead-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/decisiongraph/policyhead.py
  - src/decisiongraph/__init__.py
  - tests/test_policyhead.py
autonomous: true

must_haves:
  truths:
    - "User can call get_current_policy_head(chain, namespace) to retrieve latest PolicyHead"
    - "PolicyHead cells link via prev_policy_head field within same namespace"
    - "get_current_policy_head returns None for namespace with no PolicyHeads"
    - "Multiple namespaces maintain independent PolicyHead chains"
  artifacts:
    - path: "src/decisiongraph/policyhead.py"
      provides: "get_current_policy_head query function"
      exports: ["get_current_policy_head"]
    - path: "src/decisiongraph/__init__.py"
      provides: "Public API exports for policyhead module"
      contains: "from .policyhead import"
    - path: "tests/test_policyhead.py"
      provides: "PolicyHead chain and query tests"
      contains: "TestGetCurrentPolicyHead"
  key_links:
    - from: "src/decisiongraph/policyhead.py"
      to: "src/decisiongraph/chain.py"
      via: "Chain.find_by_type(CellType.POLICY_HEAD)"
      pattern: "find_by_type.*POLICY_HEAD"
    - from: "src/decisiongraph/__init__.py"
      to: "src/decisiongraph/policyhead.py"
      via: "public API export"
      pattern: "from.*policyhead.*import"
---

<objective>
Implement PolicyHead chain operations: linking PolicyHeads via prev_policy_head and querying the current PolicyHead for a namespace.

Purpose: Enables append-only policy chain within each namespace (POL-03) and provides query interface for current policy (POL-04).

Output: Working get_current_policy_head() function that retrieves the latest PolicyHead for any namespace.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-policyhead-foundation/01-RESEARCH.md

# Depends on Plan 01 completion
@.planning/phases/01-policyhead-foundation/01-01-SUMMARY.md

@src/decisiongraph/policyhead.py
@src/decisiongraph/chain.py
@src/decisiongraph/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add get_current_policy_head and chain traversal functions</name>
  <files>src/decisiongraph/policyhead.py</files>
  <action>
Add the following functions to src/decisiongraph/policyhead.py (after verify_policy_hash):

```python
def get_current_policy_head(
    chain: 'Chain',
    namespace: str
) -> Optional[DecisionCell]:
    """
    Get the current (most recent) PolicyHead for a namespace.

    This is the primary query interface for PolicyHead (POL-04).
    Returns the PolicyHead with the latest system_time for the given namespace.

    Args:
        chain: The Chain to search
        namespace: The namespace to get current policy for

    Returns:
        The most recent PolicyHead cell for the namespace, or None if no PolicyHeads exist

    Example:
        >>> current = get_current_policy_head(chain, "corp.hr")
        >>> if current:
        ...     data = parse_policy_data(current)
        ...     print(f"Active rules: {data['promoted_rule_ids']}")
    """
    # Find all POLICY_HEAD cells for this namespace
    policy_heads = [
        cell for cell in chain.find_by_type(CellType.POLICY_HEAD)
        if cell.fact.namespace == namespace
    ]

    if not policy_heads:
        return None

    # Sort by system_time (most recent last) and return latest
    # system_time is ISO 8601, so string sort works correctly
    policy_heads.sort(key=lambda c: c.header.system_time)
    return policy_heads[-1]


def get_policy_head_chain(
    chain: 'Chain',
    namespace: str
) -> List[DecisionCell]:
    """
    Get all PolicyHeads for a namespace in chronological order.

    Returns the complete policy history for a namespace, ordered
    from oldest to newest. Useful for audit trails and time-travel queries.

    Args:
        chain: The Chain to search
        namespace: The namespace to get policy history for

    Returns:
        List of PolicyHead cells ordered by system_time (oldest first)
    """
    policy_heads = [
        cell for cell in chain.find_by_type(CellType.POLICY_HEAD)
        if cell.fact.namespace == namespace
    ]

    # Sort by system_time (chronological order)
    policy_heads.sort(key=lambda c: c.header.system_time)
    return policy_heads


def get_policy_head_at_time(
    chain: 'Chain',
    namespace: str,
    as_of_time: str
) -> Optional[DecisionCell]:
    """
    Get the PolicyHead that was active at a specific point in time.

    This enables bitemporal "what policy was active when?" queries.
    Returns the most recent PolicyHead with system_time <= as_of_time.

    Args:
        chain: The Chain to search
        namespace: The namespace to query
        as_of_time: ISO 8601 timestamp to query at

    Returns:
        The PolicyHead that was active at as_of_time, or None

    Example:
        >>> # What was the policy at midnight Jan 1, 2026?
        >>> policy = get_policy_head_at_time(chain, "corp.hr", "2026-01-01T00:00:00Z")
    """
    # Get all PolicyHeads up to as_of_time
    policy_heads = [
        cell for cell in chain.find_by_type(CellType.POLICY_HEAD)
        if cell.fact.namespace == namespace
        and cell.header.system_time <= as_of_time
    ]

    if not policy_heads:
        return None

    # Return the most recent one at or before as_of_time
    policy_heads.sort(key=lambda c: c.header.system_time)
    return policy_heads[-1]


def validate_policy_head_chain(
    chain: 'Chain',
    namespace: str
) -> Tuple[bool, List[str]]:
    """
    Validate the PolicyHead chain for a namespace.

    Checks:
    1. All PolicyHeads have valid policy_hash
    2. prev_policy_head links are valid (exist and are older)
    3. No gaps in prev_policy_head chain (each points to previous)

    Args:
        chain: The Chain to validate
        namespace: The namespace to validate

    Returns:
        Tuple of (is_valid, list_of_errors)
    """
    errors = []
    policy_heads = get_policy_head_chain(chain, namespace)

    if not policy_heads:
        return True, []  # Empty chain is valid

    # Check first PolicyHead has prev_policy_head=None
    first_data = parse_policy_data(policy_heads[0])
    if first_data["prev_policy_head"] is not None:
        errors.append(
            f"First PolicyHead should have prev_policy_head=None, "
            f"got '{first_data['prev_policy_head']}'"
        )

    # Check each PolicyHead
    for i, ph in enumerate(policy_heads):
        # Verify policy_hash
        if not verify_policy_hash(ph):
            errors.append(
                f"PolicyHead {ph.cell_id[:16]}... has invalid policy_hash"
            )

        # Check prev_policy_head links (skip first)
        if i > 0:
            ph_data = parse_policy_data(ph)
            expected_prev = policy_heads[i - 1].cell_id

            if ph_data["prev_policy_head"] != expected_prev:
                errors.append(
                    f"PolicyHead {ph.cell_id[:16]}... has prev_policy_head="
                    f"'{ph_data['prev_policy_head'][:16] if ph_data['prev_policy_head'] else None}...', "
                    f"expected '{expected_prev[:16]}...'"
                )

    return len(errors) == 0, errors
```

Also add imports at the top:
```python
from typing import List, Optional, Tuple, TYPE_CHECKING

if TYPE_CHECKING:
    from .chain import Chain
```

Update __all__ to include new exports:
```python
__all__ = [
    # Creation
    'create_policy_head',

    # Query
    'get_current_policy_head',
    'get_policy_head_chain',
    'get_policy_head_at_time',

    # Parsing/verification
    'parse_policy_data',
    'verify_policy_hash',
    'validate_policy_head_chain',

    # Constants
    'POLICY_PROMOTION_RULE',
    'POLICY_PROMOTION_RULE_HASH',
    'POLICYHEAD_SCHEMA_VERSION'
]
```

IMPORTANT: Use TYPE_CHECKING for Chain import to avoid circular imports. The Chain type hint is only used for documentation/IDE support.
  </action>
  <verify>
Run: `python -c "from decisiongraph.policyhead import get_current_policy_head, get_policy_head_chain, get_policy_head_at_time; print('Imports OK')"`
Expected: "Imports OK" without errors.
  </verify>
  <done>
- get_current_policy_head() function exists and finds latest PolicyHead by namespace
- get_policy_head_chain() returns all PolicyHeads for namespace in chronological order
- get_policy_head_at_time() enables bitemporal queries
- validate_policy_head_chain() verifies prev_policy_head links
  </done>
</task>

<task type="auto">
  <name>Task 2: Export policyhead functions from package __init__.py</name>
  <files>src/decisiongraph/__init__.py</files>
  <action>
Update src/decisiongraph/__init__.py to export policyhead functions.

Add after existing imports (find a suitable location, likely after chain imports):

```python
# PolicyHead (v1.5)
from .policyhead import (
    create_policy_head,
    get_current_policy_head,
    get_policy_head_chain,
    get_policy_head_at_time,
    parse_policy_data,
    verify_policy_hash,
    validate_policy_head_chain,
    POLICY_PROMOTION_RULE_HASH,
    POLICYHEAD_SCHEMA_VERSION
)
```

Also add compute_policy_hash to the cell imports if not already exported:
```python
from .cell import (
    # ... existing imports ...
    compute_policy_hash,  # Add this if not present
)
```

Update __all__ list to include:
```python
# PolicyHead (v1.5)
'create_policy_head',
'get_current_policy_head',
'get_policy_head_chain',
'get_policy_head_at_time',
'parse_policy_data',
'verify_policy_hash',
'validate_policy_head_chain',
'compute_policy_hash',
'POLICY_PROMOTION_RULE_HASH',
'POLICYHEAD_SCHEMA_VERSION',
```

IMPORTANT: Read the existing __init__.py first to understand the structure and add imports in a consistent style.
  </action>
  <verify>
Run: `python -c "from decisiongraph import create_policy_head, get_current_policy_head, compute_policy_hash; print('Public API OK')"`
Expected: "Public API OK" without import errors.
  </verify>
  <done>
- decisiongraph package exports create_policy_head
- decisiongraph package exports get_current_policy_head
- decisiongraph package exports compute_policy_hash
- decisiongraph package exports all policyhead helper functions
  </done>
</task>

<task type="auto">
  <name>Task 3: Add PolicyHead chain and query tests</name>
  <files>tests/test_policyhead.py</files>
  <action>
Add the following test classes to tests/test_policyhead.py:

```python
class TestGetCurrentPolicyHead:
    """Tests for get_current_policy_head function (POL-04)"""

    @pytest.fixture
    def test_chain(self):
        return create_chain(
            graph_name="TestGraph",
            root_namespace="corp",
            system_time=T0
        )

    def test_returns_none_for_empty_namespace(self, test_chain):
        """Should return None when no PolicyHeads exist for namespace"""
        from decisiongraph.policyhead import get_current_policy_head

        result = get_current_policy_head(test_chain, "corp.hr")
        assert result is None

    def test_returns_single_policy_head(self, test_chain):
        """Should return the only PolicyHead when one exists"""
        from decisiongraph.policyhead import get_current_policy_head

        ph = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v1"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )
        test_chain.append(ph)

        result = get_current_policy_head(test_chain, "corp.hr")
        assert result == ph

    def test_returns_most_recent_policy_head(self, test_chain):
        """Should return the most recent PolicyHead by system_time"""
        from decisiongraph.policyhead import get_current_policy_head

        ph1 = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v1"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )
        test_chain.append(ph1)

        ph2 = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v1", "rule:v2"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            prev_policy_head=ph1.cell_id,
            system_time=T2
        )
        test_chain.append(ph2)

        result = get_current_policy_head(test_chain, "corp.hr")
        assert result == ph2

    def test_namespaces_are_independent(self, test_chain):
        """Different namespaces should have independent PolicyHeads"""
        from decisiongraph.policyhead import get_current_policy_head

        ph_hr = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:hr_v1"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )
        test_chain.append(ph_hr)

        ph_sales = create_policy_head(
            namespace="corp.sales",
            promoted_rule_ids=["rule:sales_v1"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )
        test_chain.append(ph_sales)

        assert get_current_policy_head(test_chain, "corp.hr") == ph_hr
        assert get_current_policy_head(test_chain, "corp.sales") == ph_sales
        assert get_current_policy_head(test_chain, "corp.finance") is None


class TestPolicyHeadChainLinking:
    """Tests for PolicyHead prev_policy_head linking (POL-03)"""

    @pytest.fixture
    def test_chain(self):
        return create_chain(
            graph_name="TestGraph",
            root_namespace="corp",
            system_time=T0
        )

    def test_first_policy_head_has_null_prev(self, test_chain):
        """First PolicyHead should have prev_policy_head=None"""
        ph = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v1"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )

        data = parse_policy_data(ph)
        assert data["prev_policy_head"] is None

    def test_subsequent_policy_heads_link_to_previous(self, test_chain):
        """Subsequent PolicyHeads should link to previous via prev_policy_head"""
        ph1 = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v1"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )
        test_chain.append(ph1)

        ph2 = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v1", "rule:v2"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            prev_policy_head=ph1.cell_id,
            system_time=T2
        )
        test_chain.append(ph2)

        data2 = parse_policy_data(ph2)
        assert data2["prev_policy_head"] == ph1.cell_id

    def test_policy_head_chain_forms_linked_list(self, test_chain):
        """PolicyHeads should form a linked list via prev_policy_head"""
        from decisiongraph.policyhead import get_policy_head_chain

        # Create chain of 3 PolicyHeads
        ph1 = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v1"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )
        test_chain.append(ph1)

        ph2 = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v2"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            prev_policy_head=ph1.cell_id,
            system_time=T2
        )
        test_chain.append(ph2)

        # Verify chain
        chain_list = get_policy_head_chain(test_chain, "corp.hr")
        assert len(chain_list) == 2
        assert chain_list[0] == ph1
        assert chain_list[1] == ph2


class TestGetPolicyHeadAtTime:
    """Tests for bitemporal PolicyHead queries"""

    @pytest.fixture
    def test_chain(self):
        return create_chain(
            graph_name="TestGraph",
            root_namespace="corp",
            system_time=T0
        )

    def test_returns_none_before_any_policy(self, test_chain):
        """Should return None when querying before any PolicyHead exists"""
        from decisiongraph.policyhead import get_policy_head_at_time

        ph = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v1"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T2  # Created at T2
        )
        test_chain.append(ph)

        # Query at T1 (before PolicyHead was created)
        result = get_policy_head_at_time(test_chain, "corp.hr", T1)
        assert result is None

    def test_returns_policy_at_exact_time(self, test_chain):
        """Should return PolicyHead when querying at its exact creation time"""
        from decisiongraph.policyhead import get_policy_head_at_time

        ph = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v1"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )
        test_chain.append(ph)

        result = get_policy_head_at_time(test_chain, "corp.hr", T1)
        assert result == ph

    def test_returns_most_recent_policy_before_time(self, test_chain):
        """Should return most recent PolicyHead at or before query time"""
        from decisiongraph.policyhead import get_policy_head_at_time

        ph1 = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v1"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )
        test_chain.append(ph1)

        ph2 = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v2"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            prev_policy_head=ph1.cell_id,
            system_time=T2
        )
        test_chain.append(ph2)

        # Query between T1 and T2 - should return ph1
        result = get_policy_head_at_time(
            test_chain,
            "corp.hr",
            "2026-01-26T10:00:30.000Z"  # Between T1 and T2
        )
        assert result == ph1


class TestValidatePolicyHeadChain:
    """Tests for PolicyHead chain validation"""

    @pytest.fixture
    def test_chain(self):
        return create_chain(
            graph_name="TestGraph",
            root_namespace="corp",
            system_time=T0
        )

    def test_empty_chain_is_valid(self, test_chain):
        """Empty PolicyHead chain should be valid"""
        from decisiongraph.policyhead import validate_policy_head_chain

        is_valid, errors = validate_policy_head_chain(test_chain, "corp.hr")
        assert is_valid is True
        assert errors == []

    def test_valid_chain_passes(self, test_chain):
        """Properly linked PolicyHead chain should pass validation"""
        from decisiongraph.policyhead import validate_policy_head_chain

        ph1 = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v1"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            system_time=T1
        )
        test_chain.append(ph1)

        ph2 = create_policy_head(
            namespace="corp.hr",
            promoted_rule_ids=["rule:v2"],
            graph_id=test_chain.graph_id,
            prev_cell_hash=test_chain.head.cell_id,
            prev_policy_head=ph1.cell_id,
            system_time=T2
        )
        test_chain.append(ph2)

        is_valid, errors = validate_policy_head_chain(test_chain, "corp.hr")
        assert is_valid is True
        assert errors == []
```

Add these imports at the top of the file if not already present:
```python
from decisiongraph.policyhead import (
    create_policy_head,
    parse_policy_data,
    verify_policy_hash,
    POLICY_PROMOTION_RULE_HASH,
    POLICYHEAD_SCHEMA_VERSION
)

# Import test time constants
from test_utils import T0, T1, T2
```

Also add T3 if needed for more time-based tests. Check test_utils.py for available constants.
  </action>
  <verify>
Run: `cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_policyhead.py::TestGetCurrentPolicyHead -v`
Expected: All tests pass.

Run full test suite: `python -m pytest tests/test_policyhead.py -v`
Expected: All tests pass (35+ tests total).
  </verify>
  <done>
- TestGetCurrentPolicyHead tests POL-04 requirements
- TestPolicyHeadChainLinking tests POL-03 requirements
- TestGetPolicyHeadAtTime tests bitemporal query capability
- TestValidatePolicyHeadChain tests chain integrity validation
- All new tests pass
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. All PolicyHead tests pass:
   ```bash
   python -m pytest tests/test_policyhead.py -v
   ```

2. Public API works correctly:
   ```python
   from decisiongraph import (
       create_chain, create_policy_head,
       get_current_policy_head, compute_policy_hash
   )

   chain = create_chain("Test", "corp")
   ph = create_policy_head(
       namespace="corp.hr",
       promoted_rule_ids=["rule:x"],
       graph_id=chain.graph_id,
       prev_cell_hash=chain.head.cell_id
   )
   chain.append(ph)

   current = get_current_policy_head(chain, "corp.hr")
   print(f"Current policy: {current.cell_id[:16]}...")
   ```

3. All existing tests still pass:
   ```bash
   python -m pytest tests/ -v --tb=short
   ```
</verification>

<success_criteria>
- get_current_policy_head(chain, namespace) returns latest PolicyHead or None
- PolicyHead cells link via prev_policy_head field
- Multiple namespaces maintain independent PolicyHead chains
- Bitemporal query (get_policy_head_at_time) works correctly
- Public API exports all policyhead functions
- All tests pass (existing + new)
</success_criteria>

<output>
After completion, create `.planning/phases/01-policyhead-foundation/01-02-SUMMARY.md`
</output>
