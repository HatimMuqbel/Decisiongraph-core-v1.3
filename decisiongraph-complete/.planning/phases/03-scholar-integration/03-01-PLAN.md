---
phase: 03-scholar-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/decisiongraph/scholar.py
autonomous: true

must_haves:
  truths:
    - "Scholar.query_facts() accepts policy_mode parameter"
    - "policy_mode='promoted_only' filters facts to only those from promoted rules"
    - "QueryResult includes policy_head_id when policy_mode='promoted_only'"
    - "No PolicyHead for namespace returns empty result with reason='no_policy_head'"
    - "Bitemporal query uses PolicyHead active at as_of_system_time"
  artifacts:
    - path: "src/decisiongraph/scholar.py"
      provides: "Policy-aware query_facts method"
      contains: "policy_mode"
    - path: "src/decisiongraph/scholar.py"
      provides: "QueryResult with policy_head_id field"
      contains: "policy_head_id: Optional[str]"
  key_links:
    - from: "src/decisiongraph/scholar.py"
      to: "src/decisiongraph/policyhead.py"
      via: "import get_policy_head_at_time, parse_policy_data"
      pattern: "from \\.policyhead import"
    - from: "Scholar.query_facts()"
      to: "get_policy_head_at_time()"
      via: "policy lookup for bitemporal query"
      pattern: "get_policy_head_at_time\\(self\\.chain"
---

<objective>
Extend Scholar with policy-aware query capability.

Purpose: Enable Scholar.query_facts() to filter results based on which rules are currently promoted (active policy), supporting bitemporal "what policy was active when?" queries.

Output:
- QueryResult extended with optional `policy_head_id` field
- Scholar.query_facts() extended with `policy_mode` parameter
- Policy filtering logic integrated into query pipeline
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-scholar-integration/03-RESEARCH.md
@src/decisiongraph/scholar.py
@src/decisiongraph/policyhead.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend QueryResult with policy_head_id field</name>
  <files>src/decisiongraph/scholar.py</files>
  <action>
Add optional `policy_head_id` field to the QueryResult dataclass (around line 97).

1. Add to dataclass fields (after `authorization` field, around line 122):
```python
# Policy tracking (v1.5 - SCH-03)
policy_head_id: Optional[str] = None  # Cell ID of PolicyHead used for filtering
```

2. Update `to_proof_bundle()` method (around line 128) to include policy information when present:
```python
# At end of bundle construction, before return:
if self.policy_head_id is not None:
    bundle["policy"] = {
        "mode": "promoted_only",
        "policy_head_id": self.policy_head_id
    }
```

3. Update `to_audit_text()` method (around line 202) to include policy section when present:
```python
# After Authorization section, before Results section:
if self.policy_head_id is not None:
    lines.append("Policy:")
    lines.append(f"  Mode: promoted_only")
    lines.append(f"  PolicyHead: {self.policy_head_id[:16]}...")
    lines.append("")
```

4. Update `to_dot()` method (around line 298) to include PolicyHead node when present:
```python
# After Bridges section, add PolicyHead node:
if self.policy_head_id is not None:
    lines.append("  // PolicyHead")
    lines.append(f'  "policy_{_short_id(self.policy_head_id)}" [label="PolicyHead\\n{_short_id(self.policy_head_id)}", fillcolor=lightyellow, shape=ellipse];')
    lines.append("")
```

This is backward compatible: existing code passes None implicitly, new code can pass explicit policy_head_id.
  </action>
  <verify>
Run: `cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -c "from decisiongraph import QueryResult; r = QueryResult(facts=[], candidates=[], bridges_used=[], resolution_events=[], valid_time='T0', system_time='T0', namespace_scope='ns', requester_id='test'); print(f'policy_head_id field exists: {hasattr(r, \"policy_head_id\")}')"` should print "policy_head_id field exists: True"
  </verify>
  <done>
QueryResult dataclass has optional policy_head_id field. to_proof_bundle(), to_audit_text(), and to_dot() methods handle policy_head_id when present. Backward compatible (None default).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add policy_mode parameter to query_facts()</name>
  <files>src/decisiongraph/scholar.py</files>
  <action>
Extend Scholar.query_facts() method with policy_mode parameter and filtering logic.

1. Add import at top of file (after existing imports, around line 33):
```python
from .policyhead import get_policy_head_at_time, parse_policy_data
```

2. Update query_facts() signature (around line 892) to add policy_mode parameter:
```python
def query_facts(
    self,
    requester_namespace: str,
    namespace: str,
    subject: Optional[str] = None,
    predicate: Optional[str] = None,
    object_value: Optional[str] = None,
    at_valid_time: Optional[str] = None,
    as_of_system_time: Optional[str] = None,
    requester_id: str = "anonymous",
    policy_mode: str = "all"  # NEW: "all" (default) or "promoted_only"
) -> QueryResult:
```

3. Update docstring (around line 903) to document policy_mode:
```python
    """
    Query facts from the vault.

    Args:
        ...existing args...
        policy_mode: Query mode for policy filtering:
            - "all": Return all facts (default, backward compatible)
            - "promoted_only": Only return facts from promoted rules

    Returns:
        QueryResult with optional policy_head_id when policy_mode="promoted_only"
    """
```

4. Add policy lookup after time defaults (after line 922, before visibility check):
```python
# Policy-aware filtering (v1.5)
policy_head_id = None
promoted_rule_ids = None

if policy_mode == "promoted_only":
    policy_head = get_policy_head_at_time(self.chain, namespace, system_time)

    if policy_head is None:
        # No policy for namespace at this time - return empty result (fail-closed)
        return QueryResult(
            facts=[],
            candidates=[],
            bridges_used=[],
            resolution_events=[],
            valid_time=valid_time,
            system_time=system_time,
            namespace_scope=namespace,
            requester_id=requester_id,
            authorization=AuthorizationBasis(
                allowed=True,
                reason="no_policy_head",
                bridges_used=[]
            ),
            policy_head_id=None
        )

    policy_data = parse_policy_data(policy_head)
    promoted_rule_ids = set(policy_data["promoted_rule_ids"])
    policy_head_id = policy_head.cell_id
```

5. Add filtering after bitemporal filter (after line 974, after the bitemporal filter):
```python
# Filter by promoted rules if policy_mode="promoted_only" (SCH-04)
if promoted_rule_ids is not None:
    candidates = [
        c for c in candidates
        if c.logic_anchor.rule_id in promoted_rule_ids
    ]
```

6. Update return statement (around line 1001) to include policy_head_id:
```python
return QueryResult(
    facts=sorted_facts,
    candidates=sorted_candidates,
    bridges_used=sorted_bridges,
    resolution_events=sorted_resolution_events,
    valid_time=valid_time,
    system_time=system_time,
    namespace_scope=namespace,
    requester_id=requester_id,
    authorization=authorization,
    policy_head_id=policy_head_id  # NEW: include when policy_mode="promoted_only"
)
```

IMPORTANT: Default policy_mode="all" must produce identical behavior to current implementation (backward compatibility). All 671 existing tests must pass.
  </action>
  <verify>
1. Run existing tests: `cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_scholar.py -v` - all tests must pass (backward compatibility)
2. Quick API check: `python -c "from decisiongraph import Scholar, create_chain; c = create_chain('Test', 'test', 'user', '2026-01-27T10:00:00Z'); s = Scholar(c); import inspect; sig = inspect.signature(s.query_facts); print('policy_mode in params:', 'policy_mode' in sig.parameters)"` should print True
  </verify>
  <done>
Scholar.query_facts() accepts policy_mode parameter ("all" or "promoted_only"). When "promoted_only": looks up PolicyHead via get_policy_head_at_time(), filters candidates by logic_anchor.rule_id, includes policy_head_id in result. Backward compatible: policy_mode="all" (default) produces identical behavior to v1.4.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. All existing Scholar tests pass (backward compatibility):
```bash
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_scholar.py -v
```

2. All existing tests pass (no regressions):
```bash
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/ -v
```

3. QueryResult has policy_head_id field accessible
4. query_facts() accepts policy_mode parameter
5. Import from policyhead works without circular import
</verification>

<success_criteria>
- [ ] QueryResult has optional policy_head_id field (None default)
- [ ] to_proof_bundle() includes policy info when policy_head_id present
- [ ] to_audit_text() includes Policy section when policy_head_id present
- [ ] to_dot() includes PolicyHead node when policy_head_id present
- [ ] query_facts() accepts policy_mode parameter
- [ ] policy_mode="all" (default) produces identical results to v1.4
- [ ] policy_mode="promoted_only" filters by promoted rules
- [ ] No PolicyHead returns empty result with reason="no_policy_head"
- [ ] All 671 existing tests pass (0 regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/03-scholar-integration/03-01-SUMMARY.md`
</output>
