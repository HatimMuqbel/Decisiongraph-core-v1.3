---
phase: 12-audit-trail
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/decisiongraph/simulation.py
  - tests/test_simulation_audit.py
autonomous: true

must_haves:
  truths:
    - "User can call simulation_result_to_dot(result) and receive valid Graphviz DOT"
    - "Graph shows BASE vs SHADOW lineage with color-coding (lightblue vs orange)"
    - "Verdict changes and anchors visually highlighted"
    - "Same SimulationResult produces identical DOT output (deterministic)"
  artifacts:
    - path: "src/decisiongraph/simulation.py"
      provides: "simulation_result_to_dot function"
      exports: ["simulation_result_to_dot"]
    - path: "tests/test_simulation_audit.py"
      provides: "DOT visualization tests"
      min_lines: 120
  key_links:
    - from: "simulation_result_to_dot"
      to: "SimulationResult"
      via: "function argument"
      pattern: "def simulation_result_to_dot\\(sim_result: SimulationResult\\)"
---

<objective>
Add DOT graph visualization with BASE vs SHADOW color-tagging to SimulationResult (AUD-03).

Purpose: Enable visual debugging, stakeholder presentations, and documentation with dual-origin lineage graphs showing what changed in the simulation.

Output: `simulation_result_to_dot(sim_result)` function in simulation.py with comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-audit-trail/12-RESEARCH.md

# Source files
@src/decisiongraph/simulation.py
@src/decisiongraph/scholar.py (lines 318-415 for to_dot pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add simulation_result_to_dot function</name>
  <files>src/decisiongraph/simulation.py</files>
  <action>
Add `simulation_result_to_dot(sim_result: SimulationResult) -> str` function to simulation.py.

Follow the EXACT pattern from QueryResult.to_dot() (scholar.py:318-415):
- Multi-line string built from `lines = []` with `lines.append()`
- Helper functions `_escape_dot_string()` and `_short_id()` defined inside
- Return `"\n".join(lines)`

**DOT Graph Structure:**

```dot
digraph simulation_lineage {
  // Simulation: {simulation_id truncated}
  rankdir=TB;
  node [shape=box, style=filled];

  // BASE subgraph
  subgraph cluster_base {
    label="BASE Reality";
    style=filled;
    fillcolor=lightgray;

    // BASE fact nodes (lightblue)
  }

  // SHADOW subgraph
  subgraph cluster_shadow {
    label="SHADOW Reality (Overlay)";
    style=filled;
    fillcolor=lightyellow;

    // SHADOW fact nodes (lightblue for unchanged, orange for shadow-origin)
    // Anchor nodes get peripheries=2, penwidth=3.0
  }

  // Delta edges (what changed)
  // Removed facts: fillcolor=pink
  // Added facts: fillcolor=lightgreen

  // Verdict change annotation
  // If verdict_changed: diamond node in red
}
```

**Implementation Details:**

1. **Helper Functions (defined inside to_dot):**
```python
def _escape_dot_string(s: str) -> str:
    """Escape quotes, backslashes, and newlines for DOT format"""
    return s.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n')

def _short_id(cell_id: str) -> str:
    """Truncate cell ID to first 12 chars + ellipsis"""
    return cell_id[:12] + "..."
```

2. **Graph Header:**
```python
lines.append("digraph simulation_lineage {")
lines.append(f"  // Simulation: {sim_result.simulation_id[:12]}...")
lines.append("  rankdir=TB;")
lines.append("  node [shape=box, style=filled];")
lines.append("")
```

3. **Extract Data:**
- `base_facts = sim_result.base_result.get("results", {}).get("fact_cell_ids", [])`
- `shadow_facts = sim_result.shadow_result.get("results", {}).get("fact_cell_ids", [])`
- `anchor_cell_ids` extracted from `sim_result.anchors.get("anchors", [])`

4. **BASE Subgraph:**
```python
lines.append("  subgraph cluster_base {")
lines.append('    label="BASE Reality";')
lines.append("    style=filled;")
lines.append("    fillcolor=lightgray;")
lines.append("")
for fact_id in sorted(base_facts):  # sorted for determinism
    node_id = f"base_{_short_id(fact_id)}"
    label = f"Fact\\n{_short_id(fact_id)}"
    lines.append(f'    "{node_id}" [label="{label}", fillcolor=lightblue];')
lines.append("  }")
```

5. **SHADOW Subgraph:**
```python
lines.append("  subgraph cluster_shadow {")
lines.append('    label="SHADOW Reality (Overlay)";')
lines.append("    style=filled;")
lines.append("    fillcolor=lightyellow;")
lines.append("")
for fact_id in sorted(shadow_facts):  # sorted for determinism
    node_id = f"shadow_{_short_id(fact_id)}"
    label = f"Fact\\n{_short_id(fact_id)}"

    # Color: orange if shadow-origin (not in base), lightblue otherwise
    fillcolor = "lightblue" if fact_id in base_facts else "orange"

    # Anchor highlighting (double border, thick pen)
    extra_attrs = ""
    if fact_id in anchor_cell_ids:
        extra_attrs = ", peripheries=2, penwidth=3.0"

    lines.append(f'    "{node_id}" [label="{label}", fillcolor={fillcolor}{extra_attrs}];')
lines.append("  }")
```

6. **Delta Edges:**
```python
lines.append("")
lines.append("  // Delta edges")
# Removed facts (pink)
for removed_id in sorted(sim_result.delta_report.facts_diff.get("removed", [])):
    lines.append(f'  "base_{_short_id(removed_id)}" [fillcolor=pink];  // REMOVED')

# Added facts (lightgreen)
for added_id in sorted(sim_result.delta_report.facts_diff.get("added", [])):
    lines.append(f'  "shadow_{_short_id(added_id)}" [fillcolor=lightgreen];  // ADDED')
```

7. **Verdict Change Annotation:**
```python
if sim_result.delta_report.verdict_changed:
    lines.append("")
    lines.append('  "verdict_delta" [label="VERDICT CHANGED", shape=diamond, fillcolor=red, fontcolor=white];')
```

8. **Graph Footer:**
```python
lines.append("")
lines.append("}")
```

**CRITICAL for AUD-03:**
- BASE nodes: fillcolor=lightblue
- SHADOW nodes that are new (not in base): fillcolor=orange
- Anchor nodes: peripheries=2, penwidth=3.0 (double border, thick)
- Removed facts: fillcolor=pink
- Added facts: fillcolor=lightgreen
- Verdict change: diamond node in red

**Determinism:** Sort ALL lists before iteration (base_facts, shadow_facts, added, removed).

**Update __all__:** Add 'simulation_result_to_dot' to the exports list.
  </action>
  <verify>
```bash
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -c "from decisiongraph.simulation import simulation_result_to_dot; print('Import OK')"
```
  </verify>
  <done>Function exists and is importable from simulation module.</done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for DOT visualization</name>
  <files>tests/test_simulation_audit.py</files>
  <action>
Append DOT visualization tests to `tests/test_simulation_audit.py`.

**Add these test classes after existing audit text tests:**

```python
# ============================================================================
# TEST: DOT VISUALIZATION (AUD-03)
# ============================================================================

class TestDotVisualization:
    """Tests for DOT graph generation (AUD-03)."""

    def test_returns_string(self, sample_simulation_result):
        """to_dot returns string."""
        result = simulation_result_to_dot(sample_simulation_result)
        assert isinstance(result, str)

    def test_valid_dot_syntax_header(self, sample_simulation_result):
        """Output starts with valid DOT digraph."""
        result = simulation_result_to_dot(sample_simulation_result)
        assert result.startswith("digraph simulation_lineage {")

    def test_valid_dot_syntax_footer(self, sample_simulation_result):
        """Output ends with closing brace."""
        result = simulation_result_to_dot(sample_simulation_result)
        assert result.strip().endswith("}")

    def test_contains_simulation_id_comment(self, sample_simulation_result):
        """Output contains truncated simulation ID as comment."""
        result = simulation_result_to_dot(sample_simulation_result)
        assert "// Simulation: sim-abc123de" in result

    def test_contains_base_subgraph(self, sample_simulation_result):
        """Output contains BASE Reality subgraph."""
        result = simulation_result_to_dot(sample_simulation_result)
        assert 'subgraph cluster_base' in result
        assert 'label="BASE Reality"' in result
        assert 'fillcolor=lightgray' in result

    def test_contains_shadow_subgraph(self, sample_simulation_result):
        """Output contains SHADOW Reality subgraph."""
        result = simulation_result_to_dot(sample_simulation_result)
        assert 'subgraph cluster_shadow' in result
        assert 'label="SHADOW Reality (Overlay)"' in result
        assert 'fillcolor=lightyellow' in result

    def test_base_nodes_lightblue(self, sample_simulation_result):
        """BASE nodes have lightblue fill color."""
        result = simulation_result_to_dot(sample_simulation_result)
        # BASE nodes should be lightblue
        assert 'fillcolor=lightblue' in result

    def test_shadow_only_nodes_orange(self, sample_simulation_result):
        """SHADOW-only nodes (not in BASE) have orange fill color."""
        result = simulation_result_to_dot(sample_simulation_result)
        # shadow_fact_123 is only in shadow, should be orange
        assert 'fillcolor=orange' in result

    def test_rankdir_top_to_bottom(self, sample_simulation_result):
        """Graph uses top-to-bottom ranking."""
        result = simulation_result_to_dot(sample_simulation_result)
        assert 'rankdir=TB' in result

    def test_node_shape_box(self, sample_simulation_result):
        """Nodes use box shape."""
        result = simulation_result_to_dot(sample_simulation_result)
        assert 'node [shape=box' in result


class TestDotDeltaHighlighting:
    """Tests for delta highlighting in DOT output."""

    def test_verdict_changed_shows_diamond(self, sample_simulation_result):
        """Verdict change shows diamond annotation."""
        result = simulation_result_to_dot(sample_simulation_result)
        # sample_simulation_result has verdict_changed=True
        assert 'shape=diamond' in result
        assert 'VERDICT CHANGED' in result

    def test_verdict_unchanged_no_diamond(self):
        """No verdict change means no diamond annotation."""
        result = SimulationResult(
            simulation_id="sim-no-change",
            rfa_dict={"namespace": "test", "requester_namespace": "test", "requester_id": "user"},
            simulation_spec={"shadow_facts": []},
            base_result={"results": {"fact_count": 1, "fact_cell_ids": ["fact1"]}, "authorization_basis": {"allowed": True}},
            shadow_result={"results": {"fact_count": 1, "fact_cell_ids": ["fact1"]}, "authorization_basis": {"allowed": True}},
            at_valid_time="2025-01-01T00:00:00Z",
            as_of_system_time="2025-01-01T00:00:00Z",
            delta_report=DeltaReport(
                verdict_changed=False,
                status_before="ALLOWED",
                status_after="ALLOWED",
                score_delta=0.0,
                facts_diff={"added": [], "removed": []},
                rules_diff={"added": [], "removed": []}
            ),
            anchors={"anchors": [], "anchors_incomplete": False},
            proof_bundle={}
        )
        dot_output = simulation_result_to_dot(result)
        assert 'VERDICT CHANGED' not in dot_output

    def test_added_facts_lightgreen(self):
        """Added facts get lightgreen color."""
        result = SimulationResult(
            simulation_id="sim-added",
            rfa_dict={"namespace": "test", "requester_namespace": "test", "requester_id": "user"},
            simulation_spec={"shadow_facts": []},
            base_result={"results": {"fact_count": 0, "fact_cell_ids": []}, "authorization_basis": {"allowed": True}},
            shadow_result={"results": {"fact_count": 1, "fact_cell_ids": ["new_fact"]}, "authorization_basis": {"allowed": True}},
            at_valid_time="2025-01-01T00:00:00Z",
            as_of_system_time="2025-01-01T00:00:00Z",
            delta_report=DeltaReport(
                verdict_changed=True,
                status_before="ALLOWED",
                status_after="ALLOWED",
                score_delta=0.0,
                facts_diff={"added": ["new_fact"], "removed": []},
                rules_diff={"added": [], "removed": []}
            ),
            anchors={"anchors": [], "anchors_incomplete": False},
            proof_bundle={}
        )
        dot_output = simulation_result_to_dot(result)
        assert 'fillcolor=lightgreen' in dot_output
        assert '// ADDED' in dot_output

    def test_removed_facts_pink(self):
        """Removed facts get pink color."""
        result = SimulationResult(
            simulation_id="sim-removed",
            rfa_dict={"namespace": "test", "requester_namespace": "test", "requester_id": "user"},
            simulation_spec={"shadow_facts": []},
            base_result={"results": {"fact_count": 1, "fact_cell_ids": ["old_fact"]}, "authorization_basis": {"allowed": True}},
            shadow_result={"results": {"fact_count": 0, "fact_cell_ids": []}, "authorization_basis": {"allowed": True}},
            at_valid_time="2025-01-01T00:00:00Z",
            as_of_system_time="2025-01-01T00:00:00Z",
            delta_report=DeltaReport(
                verdict_changed=True,
                status_before="ALLOWED",
                status_after="ALLOWED",
                score_delta=0.0,
                facts_diff={"added": [], "removed": ["old_fact"]},
                rules_diff={"added": [], "removed": []}
            ),
            anchors={"anchors": [], "anchors_incomplete": False},
            proof_bundle={}
        )
        dot_output = simulation_result_to_dot(result)
        assert 'fillcolor=pink' in dot_output
        assert '// REMOVED' in dot_output


class TestDotAnchorHighlighting:
    """Tests for anchor highlighting in DOT output."""

    def test_anchor_double_border(self, sample_simulation_result):
        """Anchor nodes have double border (peripheries=2)."""
        result = simulation_result_to_dot(sample_simulation_result)
        # sample_simulation_result has anchor: "shadow_fact:base_fact_abc123"
        # Need to check that anchor highlighting attributes exist
        assert 'peripheries=2' in result or 'penwidth=3.0' in result


class TestDotDeterminism:
    """Tests for deterministic DOT output."""

    def test_same_input_same_output(self, sample_simulation_result):
        """Same SimulationResult produces identical DOT output."""
        result1 = simulation_result_to_dot(sample_simulation_result)
        result2 = simulation_result_to_dot(sample_simulation_result)
        assert result1 == result2

    def test_deterministic_across_multiple_calls(self, sample_simulation_result):
        """DOT output is deterministic across 10 calls."""
        results = [simulation_result_to_dot(sample_simulation_result) for _ in range(10)]
        assert all(r == results[0] for r in results)


class TestDotEdgeCases:
    """Tests for DOT edge cases."""

    def test_empty_facts(self):
        """Handles empty fact lists gracefully."""
        result = SimulationResult(
            simulation_id="sim-empty",
            rfa_dict={"namespace": "test", "requester_namespace": "test", "requester_id": "user"},
            simulation_spec={"shadow_facts": []},
            base_result={"results": {"fact_count": 0, "fact_cell_ids": []}, "authorization_basis": {"allowed": True}},
            shadow_result={"results": {"fact_count": 0, "fact_cell_ids": []}, "authorization_basis": {"allowed": True}},
            at_valid_time="2025-01-01T00:00:00Z",
            as_of_system_time="2025-01-01T00:00:00Z",
            delta_report=DeltaReport(
                verdict_changed=False,
                status_before="ALLOWED",
                status_after="ALLOWED",
                score_delta=0.0,
                facts_diff={"added": [], "removed": []},
                rules_diff={"added": [], "removed": []}
            ),
            anchors={"anchors": [], "anchors_incomplete": False},
            proof_bundle={}
        )
        dot_output = simulation_result_to_dot(result)
        # Should still be valid DOT
        assert 'digraph simulation_lineage' in dot_output
        assert dot_output.strip().endswith("}")

    def test_special_characters_escaped(self):
        """Special characters in IDs are escaped properly."""
        # Cell IDs shouldn't have special chars, but test escaping anyway
        result = SimulationResult(
            simulation_id='sim-with"quotes',
            rfa_dict={"namespace": "test", "requester_namespace": "test", "requester_id": "user"},
            simulation_spec={"shadow_facts": []},
            base_result={"results": {"fact_count": 0, "fact_cell_ids": []}, "authorization_basis": {"allowed": True}},
            shadow_result={"results": {"fact_count": 0, "fact_cell_ids": []}, "authorization_basis": {"allowed": True}},
            at_valid_time="2025-01-01T00:00:00Z",
            as_of_system_time="2025-01-01T00:00:00Z",
            delta_report=DeltaReport(
                verdict_changed=False,
                status_before="ALLOWED",
                status_after="ALLOWED",
                score_delta=0.0,
                facts_diff={"added": [], "removed": []},
                rules_diff={"added": [], "removed": []}
            ),
            anchors={"anchors": [], "anchors_incomplete": False},
            proof_bundle={}
        )
        dot_output = simulation_result_to_dot(result)
        # Should not crash, quotes should be escaped
        assert 'digraph simulation_lineage' in dot_output
```

**Also add import at top of file:**
```python
from decisiongraph.simulation import (
    SimulationResult,
    DeltaReport,
    simulation_result_to_audit_text,
    simulation_result_to_dot  # ADD THIS
)
```
  </action>
  <verify>
```bash
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_simulation_audit.py -v
```
  </verify>
  <done>All 35+ tests pass (17 audit text + 18+ DOT tests), covering structure, colors, anchors, determinism, and edge cases.</done>
</task>

</tasks>

<verification>
1. Function exists: `python -c "from decisiongraph.simulation import simulation_result_to_dot"`
2. All tests pass: `pytest tests/test_simulation_audit.py -v`
3. No regressions: `pytest tests/ -v` (all 892+ tests pass)
4. Determinism: Same SimulationResult produces identical DOT output
5. AUD-03 satisfied: BASE (lightblue) vs SHADOW (orange) color-tagging visible
6. Valid DOT syntax: Output can be rendered with Graphviz
</verification>

<success_criteria>
- [ ] simulation_result_to_dot() function added to simulation.py
- [ ] Function exported in __all__
- [ ] BASE subgraph with lightgray background, lightblue fact nodes
- [ ] SHADOW subgraph with lightyellow background
- [ ] Shadow-only nodes in orange (AUD-03 color-tagging)
- [ ] Anchor nodes have peripheries=2, penwidth=3.0
- [ ] Added facts highlighted lightgreen
- [ ] Removed facts highlighted pink
- [ ] Verdict change shown with red diamond
- [ ] Output is deterministic (same input = same output)
- [ ] All tests pass (18+ new tests)
- [ ] No regressions (all existing tests pass)
</success_criteria>

<output>
After completion, create `.planning/phases/12-audit-trail/12-02-SUMMARY.md`
</output>
