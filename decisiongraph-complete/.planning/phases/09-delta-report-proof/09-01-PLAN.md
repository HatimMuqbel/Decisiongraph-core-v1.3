---
phase: 09-delta-report-proof
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/decisiongraph/simulation.py
autonomous: true

must_haves:
  truths:
    - "DeltaReport frozen dataclass exists with verdict_changed, status_before, status_after, score_delta, facts_diff, rules_diff fields"
    - "ContaminationAttestation frozen dataclass exists with chain_head_before, chain_head_after, attestation_hash, contamination_detected fields"
    - "compute_delta_report() function returns DeltaReport from two proof bundles deterministically"
    - "tag_proof_bundle_origin() function returns tagged copy without mutating original"
    - "create_contamination_attestation() function returns ContaminationAttestation with SHA-256 hash"
  artifacts:
    - path: "src/decisiongraph/simulation.py"
      provides: "DeltaReport, ContaminationAttestation, compute_delta_report, tag_proof_bundle_origin, create_contamination_attestation"
      contains: "class DeltaReport"
  key_links:
    - from: "compute_delta_report"
      to: "sorted()"
      via: "deterministic list comparison"
      pattern: "sorted.*-"
    - from: "tag_proof_bundle_origin"
      to: "copy.deepcopy"
      via: "immutable tagging"
      pattern: "deepcopy"
    - from: "create_contamination_attestation"
      to: "hashlib.sha256"
      via: "attestation hash"
      pattern: "sha256"
---

<objective>
Create DeltaReport and ContaminationAttestation frozen dataclasses with deterministic computation functions.

Purpose: Phase 9 requirements (SIM-04, SIM-05, SIM-06, SHD-06) require structured delta reporting and contamination proof. These dataclasses and helpers are the foundation for Engine integration in Plan 02.

Output: Extended simulation.py with DeltaReport, ContaminationAttestation, compute_delta_report(), tag_proof_bundle_origin(), create_contamination_attestation() functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-delta-report-proof/09-RESEARCH.md

# Key source files
@src/decisiongraph/simulation.py
@src/decisiongraph/scholar.py (lines 132-213 for to_proof_bundle() structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DeltaReport and ContaminationAttestation frozen dataclasses</name>
  <files>src/decisiongraph/simulation.py</files>
  <action>
Add to simulation.py after existing imports:

1. Add imports at top of file:
   ```python
   import copy
   import hashlib
   import json
   ```

2. Add DeltaReport frozen dataclass (after SimulationResult):
   ```python
   @dataclass(frozen=True)
   class DeltaReport:
       """Deterministic delta between base and shadow query results (SIM-04).

       All fields computed from comparing base_result and shadow_result proof bundles.
       Uses sorted lists for deterministic output (same inputs = identical DeltaReport).
       """
       verdict_changed: bool          # Did fact count change?
       status_before: str             # "ALLOWED" or "DENIED" (base)
       status_after: str              # "ALLOWED" or "DENIED" (shadow)
       score_delta: float             # Average confidence change (placeholder: 0.0)
       facts_diff: Dict[str, List[str]]   # {"added": [...], "removed": [...]}
       rules_diff: Dict[str, List[str]]   # {"added": [...], "removed": [...]}
   ```

3. Add ContaminationAttestation frozen dataclass:
   ```python
   @dataclass(frozen=True)
   class ContaminationAttestation:
       """Proof that chain head unchanged during simulation (SHD-06).

       Captures chain.head.cell_id before and after simulation.
       attestation_hash is SHA-256 of (before|after|simulation_id) for tamper-evidence.
       contamination_detected should NEVER be True due to structural isolation.
       """
       chain_head_before: str
       chain_head_after: str
       attestation_hash: str
       contamination_detected: bool
   ```

4. Update __all__ to export new classes.

IMPORTANT: Maintain frozen=True for determinism. All fields must be immutable (str, bool, float, Dict with sorted lists).
  </action>
  <verify>
Run: `python -c "from decisiongraph.simulation import DeltaReport, ContaminationAttestation; print('Dataclasses imported successfully')"`
  </verify>
  <done>DeltaReport and ContaminationAttestation frozen dataclasses exist in simulation.py with all required fields.</done>
</task>

<task type="auto">
  <name>Task 2: Implement compute_delta_report(), tag_proof_bundle_origin(), create_contamination_attestation()</name>
  <files>src/decisiongraph/simulation.py</files>
  <action>
Add helper functions after the dataclass definitions:

1. compute_delta_report(base_result: Dict, shadow_result: Dict) -> DeltaReport:
   ```python
   def compute_delta_report(base_result: Dict, shadow_result: Dict) -> DeltaReport:
       """Compute deterministic delta report between base and shadow results (SIM-04, SIM-06).

       Args:
           base_result: Proof bundle from base query (via QueryResult.to_proof_bundle())
           shadow_result: Proof bundle from shadow query

       Returns:
           DeltaReport with deterministic diff fields (sorted lists for reproducibility)
       """
       # Extract fact sets
       base_facts = set(base_result.get("results", {}).get("fact_cell_ids", []))
       shadow_facts = set(shadow_result.get("results", {}).get("fact_cell_ids", []))

       # Compute differences (CRITICAL: sorted for determinism - SIM-06)
       added_facts = sorted(list(shadow_facts - base_facts))
       removed_facts = sorted(list(base_facts - shadow_facts))

       # Verdict changed if fact count differs
       base_count = base_result.get("results", {}).get("fact_count", 0)
       shadow_count = shadow_result.get("results", {}).get("fact_count", 0)
       verdict_changed = (base_count != shadow_count)

       # Authorization status
       base_auth = base_result.get("authorization_basis", {})
       shadow_auth = shadow_result.get("authorization_basis", {})
       status_before = "ALLOWED" if base_auth.get("allowed", False) else "DENIED"
       status_after = "ALLOWED" if shadow_auth.get("allowed", False) else "DENIED"

       # Score delta (placeholder - Phase 10 may compute from confidence)
       score_delta = 0.0

       # Rules diff (extract from candidates if tracked - placeholder for now)
       rules_diff = {"added": [], "removed": []}

       return DeltaReport(
           verdict_changed=verdict_changed,
           status_before=status_before,
           status_after=status_after,
           score_delta=score_delta,
           facts_diff={"added": added_facts, "removed": removed_facts},
           rules_diff=rules_diff
       )
   ```

2. tag_proof_bundle_origin(proof_bundle: Dict, origin: str) -> Dict:
   ```python
   def tag_proof_bundle_origin(proof_bundle: Dict, origin: str) -> Dict:
       """Tag proof bundle nodes with origin ("BASE" or "SHADOW") for lineage clarity (SIM-05).

       Deep copies bundle to avoid mutating original (immutability preservation).
       Adds origin field to top level and tags each cell ID.

       Args:
           proof_bundle: Proof bundle from QueryResult.to_proof_bundle()
           origin: "BASE" or "SHADOW"

       Returns:
           Tagged copy of proof bundle with origin markers
       """
       # CRITICAL: Deep copy to preserve original immutability
       tagged = copy.deepcopy(proof_bundle)

       # Add origin to top level
       tagged["origin"] = origin

       # Tag result fact cell IDs (backward compatible - keep original list)
       if "results" in tagged and "fact_cell_ids" in tagged["results"]:
           original_ids = tagged["results"]["fact_cell_ids"]
           tagged["results"]["fact_cell_ids_with_origin"] = [
               {"cell_id": cid, "origin": origin}
               for cid in original_ids
           ]

       # Tag candidate cell IDs
       if "proof" in tagged and "candidate_cell_ids" in tagged["proof"]:
           original_ids = tagged["proof"]["candidate_cell_ids"]
           tagged["proof"]["candidate_cell_ids_with_origin"] = [
               {"cell_id": cid, "origin": origin}
               for cid in original_ids
           ]

       # Tag bridges used
       if "proof" in tagged and "bridges_used" in tagged["proof"]:
           original_ids = tagged["proof"]["bridges_used"]
           tagged["proof"]["bridges_used_with_origin"] = [
               {"cell_id": cid, "origin": origin}
               for cid in original_ids
           ]

       return tagged
   ```

3. create_contamination_attestation(...) -> ContaminationAttestation:
   ```python
   def create_contamination_attestation(
       chain_head_before: str,
       chain_head_after: str,
       simulation_id: str
   ) -> ContaminationAttestation:
       """Create attestation proving chain unchanged during simulation (SHD-06).

       Args:
           chain_head_before: chain.head.cell_id captured before simulation
           chain_head_after: chain.head.cell_id captured after simulation
           simulation_id: Unique simulation identifier for attestation

       Returns:
           ContaminationAttestation with SHA-256 attestation hash
       """
       # Create attestation payload (pipe-delimited for clarity)
       payload = f"{chain_head_before}|{chain_head_after}|{simulation_id}"

       # SHA-256 hash for tamper-evidence
       attestation_hash = hashlib.sha256(payload.encode('utf-8')).hexdigest()

       # Detect contamination (should NEVER be True due to structural isolation)
       contamination_detected = (chain_head_before != chain_head_after)

       return ContaminationAttestation(
           chain_head_before=chain_head_before,
           chain_head_after=chain_head_after,
           attestation_hash=attestation_hash,
           contamination_detected=contamination_detected
       )
   ```

4. Update __all__ to export: compute_delta_report, tag_proof_bundle_origin, create_contamination_attestation

IMPORTANT:
- Use sorted() for all list comparisons (SIM-06 determinism)
- Use copy.deepcopy() to avoid mutating proof bundles (immutability)
- Use hashlib.sha256() for attestation (standard, collision-resistant)
  </action>
  <verify>
Run unit tests for the new functions:
```python
python -c "
from decisiongraph.simulation import compute_delta_report, tag_proof_bundle_origin, create_contamination_attestation

# Test compute_delta_report
base = {'results': {'fact_cell_ids': ['a', 'b'], 'fact_count': 2}, 'authorization_basis': {'allowed': True}}
shadow = {'results': {'fact_cell_ids': ['b', 'c'], 'fact_count': 2}, 'authorization_basis': {'allowed': True}}
delta = compute_delta_report(base, shadow)
assert delta.facts_diff['added'] == ['c'], f'Expected added [c], got {delta.facts_diff}'
assert delta.facts_diff['removed'] == ['a'], f'Expected removed [a], got {delta.facts_diff}'
print('compute_delta_report: PASS')

# Test tag_proof_bundle_origin
bundle = {'results': {'fact_cell_ids': ['x']}, 'proof': {'candidate_cell_ids': ['y']}}
tagged = tag_proof_bundle_origin(bundle, 'BASE')
assert tagged['origin'] == 'BASE', 'Origin not set'
assert bundle.get('origin') is None, 'Original mutated!'
print('tag_proof_bundle_origin: PASS')

# Test create_contamination_attestation
att = create_contamination_attestation('head1', 'head1', 'sim123')
assert att.contamination_detected == False, 'Should not detect contamination'
assert len(att.attestation_hash) == 64, 'SHA-256 should be 64 hex chars'
print('create_contamination_attestation: PASS')

print('All helper functions working correctly')
"
```
  </verify>
  <done>compute_delta_report(), tag_proof_bundle_origin(), and create_contamination_attestation() functions implemented with deterministic behavior and proper immutability.</done>
</task>

<task type="auto">
  <name>Task 3: Extend SimulationResult with delta_report, anchors, proof_bundle fields</name>
  <files>src/decisiongraph/simulation.py</files>
  <action>
Modify the existing SimulationResult frozen dataclass to add Phase 9 fields:

1. Add new fields after as_of_system_time (use field() with default for backward compatibility):
   ```python
   @dataclass(frozen=True)
   class SimulationResult:
       """Immutable simulation result (SHD-03).

       Phase 8 fields: simulation_id, rfa_dict, simulation_spec, base_result,
                       shadow_result, at_valid_time, as_of_system_time

       Phase 9 additions (SHD-03, SIM-04, SIM-05, SHD-06):
           delta_report: DeltaReport comparing base vs shadow (SIM-04)
           anchors: Dict for counterfactual anchors (empty until Phase 10)
           proof_bundle: Combined tagged bundles with attestation (SIM-05, SHD-06)
       """
       # Phase 8 fields (existing)
       simulation_id: str
       rfa_dict: Dict[str, Any]
       simulation_spec: Dict[str, Any]
       base_result: Dict[str, Any]
       shadow_result: Dict[str, Any]
       at_valid_time: str
       as_of_system_time: str

       # Phase 9 additions (SHD-03)
       delta_report: Optional['DeltaReport'] = None      # SIM-04
       anchors: Dict[str, Any] = field(default_factory=dict)  # CTF-03 (Phase 10, empty for now)
       proof_bundle: Dict[str, Any] = field(default_factory=dict)  # SIM-05, SHD-06
   ```

2. Update to_dict() to include new fields:
   ```python
   def to_dict(self) -> Dict[str, Any]:
       """Convert to serializable dict with deterministic ordering (SIM-06)."""
       result = {
           "simulation_id": self.simulation_id,
           "rfa_dict": self.rfa_dict,
           "simulation_spec": self.simulation_spec,
           "base_result": self.base_result,
           "shadow_result": self.shadow_result,
           "at_valid_time": self.at_valid_time,
           "as_of_system_time": self.as_of_system_time,
           "anchors": self.anchors,
           "proof_bundle": self.proof_bundle
       }
       # Add delta_report if present
       if self.delta_report is not None:
           result["delta_report"] = {
               "verdict_changed": self.delta_report.verdict_changed,
               "status_before": self.delta_report.status_before,
               "status_after": self.delta_report.status_after,
               "score_delta": self.delta_report.score_delta,
               "facts_diff": self.delta_report.facts_diff,
               "rules_diff": self.delta_report.rules_diff
           }
       # Return with sorted keys for determinism
       return json.loads(json.dumps(result, sort_keys=True))
   ```

3. Add Optional import at top if not present:
   ```python
   from typing import Dict, Any, Optional, List
   ```

NOTE: Use Optional[DeltaReport] = None for backward compatibility with existing code that creates SimulationResult without delta_report.
  </action>
  <verify>
Run:
```python
python -c "
from decisiongraph.simulation import SimulationResult, DeltaReport

# Test backward compatibility (no delta_report)
r1 = SimulationResult(
    simulation_id='test',
    rfa_dict={},
    simulation_spec={},
    base_result={},
    shadow_result={},
    at_valid_time='2025-01-01T00:00:00Z',
    as_of_system_time='2025-01-01T00:00:00Z'
)
assert r1.delta_report is None, 'Should default to None'
assert r1.anchors == {}, 'Should default to empty dict'
print('Backward compatibility: PASS')

# Test with delta_report
delta = DeltaReport(
    verdict_changed=True,
    status_before='ALLOWED',
    status_after='DENIED',
    score_delta=0.0,
    facts_diff={'added': [], 'removed': ['x']},
    rules_diff={'added': [], 'removed': []}
)
r2 = SimulationResult(
    simulation_id='test2',
    rfa_dict={},
    simulation_spec={},
    base_result={},
    shadow_result={},
    at_valid_time='2025-01-01T00:00:00Z',
    as_of_system_time='2025-01-01T00:00:00Z',
    delta_report=delta,
    proof_bundle={'base': {}, 'shadow': {}}
)
d = r2.to_dict()
assert 'delta_report' in d, 'delta_report missing from to_dict()'
assert d['delta_report']['verdict_changed'] == True, 'verdict_changed incorrect'
print('Extended SimulationResult: PASS')
"
```
  </verify>
  <done>SimulationResult extended with delta_report, anchors, and proof_bundle fields. Backward compatible with existing Phase 8 code.</done>
</task>

</tasks>

<verification>
1. All new dataclasses import successfully:
   `python -c "from decisiongraph.simulation import DeltaReport, ContaminationAttestation"`

2. All helper functions work correctly (inline tests in Task 2 verify)

3. SimulationResult backward compatible:
   `python -c "from decisiongraph.simulation import SimulationResult; r = SimulationResult(simulation_id='x', rfa_dict={}, simulation_spec={}, base_result={}, shadow_result={}, at_valid_time='t', as_of_system_time='t'); print('OK')"`

4. No existing tests broken:
   `pytest tests/test_simulation.py -v --tb=short`

5. Determinism verification:
   `python -c "from decisiongraph.simulation import compute_delta_report; b={'results':{'fact_cell_ids':['z','a'],'fact_count':2},'authorization_basis':{'allowed':True}}; s={'results':{'fact_cell_ids':['a','m'],'fact_count':2},'authorization_basis':{'allowed':True}}; d1=compute_delta_report(b,s); d2=compute_delta_report(b,s); assert d1==d2, 'Not deterministic!'"`
</verification>

<success_criteria>
- [ ] DeltaReport frozen dataclass with verdict_changed, status_before, status_after, score_delta, facts_diff, rules_diff
- [ ] ContaminationAttestation frozen dataclass with chain_head_before, chain_head_after, attestation_hash, contamination_detected
- [ ] compute_delta_report() returns DeltaReport deterministically (sorted lists)
- [ ] tag_proof_bundle_origin() returns tagged copy without mutating original
- [ ] create_contamination_attestation() returns attestation with SHA-256 hash
- [ ] SimulationResult extended with delta_report, anchors, proof_bundle (backward compatible)
- [ ] All existing simulation tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/09-delta-report-proof/09-01-SUMMARY.md` using the summary template.
</output>
