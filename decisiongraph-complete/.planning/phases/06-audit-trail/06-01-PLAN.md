---
phase: 06-audit-trail
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/decisiongraph/policyhead.py
  - tests/test_policyhead.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can call policy_head_to_audit_text(policy_head) and receive deterministic human-readable report"
    - "Report includes namespace, cell_id, system_time, policy_hash, promoted_rule_ids"
    - "Report includes prev_policy_head link (or genesis indicator)"
    - "Report includes witness_signatures count and witness IDs"
    - "Report includes submitter_id from proof.signer_id"
    - "Same PolicyHead always produces identical audit text"
  artifacts:
    - path: "src/decisiongraph/policyhead.py"
      provides: "policy_head_to_audit_text() function"
      contains: "def policy_head_to_audit_text"
    - path: "tests/test_policyhead.py"
      provides: "Tests for audit text generation"
      contains: "class TestPolicyHeadAuditText"
  key_links:
    - from: "policy_head_to_audit_text()"
      to: "parse_policy_data()"
      via: "function call to extract policy_hash, promoted_rule_ids, etc."
      pattern: "parse_policy_data\\(policy_head\\)"
    - from: "policy_head_to_audit_text()"
      to: "__all__ export"
      via: "module export for public API"
      pattern: "'policy_head_to_audit_text'"
---

<objective>
Create policy_head_to_audit_text() function that generates human-readable audit reports for PolicyHead cells.

Purpose: Enable compliance auditing and human review of PolicyHead contents (AUD-01).
Output: Module-level function in policyhead.py with comprehensive test coverage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-audit-trail/06-RESEARCH.md
@src/decisiongraph/policyhead.py
@src/decisiongraph/scholar.py (QueryResult.to_audit_text pattern - lines 215-316)
@tests/test_policyhead.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement policy_head_to_audit_text function</name>
  <files>src/decisiongraph/policyhead.py</files>
  <action>
Add a module-level function `policy_head_to_audit_text(policy_head: DecisionCell) -> str` to policyhead.py.

Follow the exact pattern from QueryResult.to_audit_text() in scholar.py (lines 215-316):

1. Build lines list with:
   - Header: "POLICYHEAD AUDIT REPORT" with "=" separator
   - Policy Snapshot section: namespace, cell_id (truncated to 16 chars + "..."), system_time
   - Policy Hash section: policy_hash (truncated), promoted_rule_ids count, list of rule IDs
   - Chain Link section: prev_policy_head (truncated) or "(genesis - first policy)"
   - Witness Signatures section: signature count, witness IDs (sorted alphabetically)
   - Promotion Context section: submitter from proof.signer_id
   - Footer: Schema Version from header.version

2. Use parse_policy_data() to extract policy_data fields
3. Use sorted() for witness_signatures keys to ensure deterministic output
4. Truncate IDs: cell_id[:16] + "...", policy_hash[:16] + "..."
5. Return "\n".join(lines)

Add to __all__ export list: 'policy_head_to_audit_text'

Format example (from RESEARCH.md):
```
POLICYHEAD AUDIT REPORT
==================================================

Policy Snapshot:
  Namespace: corp.hr
  Cell ID: a1b2c3d4e5f6...
  System Time: 2026-01-28T10:00:00Z

Policy Hash:
  Hash: abc123def456...
  Promoted Rules: 3
    - rule:salary_v1
    - rule:benefits_v2
    - rule:vacation_v1

Chain Link:
  Previous PolicyHead: xyz789...

Witness Signatures:
  Signatures Collected: 2
    - alice: (signature present)
    - bob: (signature present)

Promotion Context:
  Submitter: admin:alice

Schema Version: 1.5
```

Note: Justification field is N/A (not stored in PromotionRequest per RESEARCH.md).
  </action>
  <verify>
Run: `python -c "from decisiongraph.policyhead import policy_head_to_audit_text; print('Import OK')"`
  </verify>
  <done>
Function exists, imports successfully, follows QueryResult.to_audit_text pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for audit text generation</name>
  <files>tests/test_policyhead.py</files>
  <action>
Add a new test class `TestPolicyHeadAuditText` to tests/test_policyhead.py with the following tests:

1. `test_audit_text_contains_required_sections`:
   - Create PolicyHead with known values
   - Call policy_head_to_audit_text()
   - Assert contains: "POLICYHEAD AUDIT REPORT", "Policy Snapshot:", "Policy Hash:", "Chain Link:", "Witness Signatures:", "Promotion Context:", "Schema Version:"

2. `test_audit_text_shows_namespace_and_cell_id`:
   - Create PolicyHead for "corp.hr" namespace
   - Assert audit text contains "Namespace: corp.hr"
   - Assert audit text contains truncated cell_id

3. `test_audit_text_shows_promoted_rules`:
   - Create PolicyHead with promoted_rule_ids=["rule:a", "rule:b"]
   - Assert audit text contains "Promoted Rules: 2"
   - Assert audit text contains "rule:a" and "rule:b"

4. `test_audit_text_shows_genesis_for_first_policy`:
   - Create PolicyHead with prev_policy_head=None
   - Assert audit text contains "(genesis - first policy)"

5. `test_audit_text_shows_prev_policy_head_link`:
   - Create PolicyHead with prev_policy_head="abc123def456..."
   - Assert audit text contains truncated prev_policy_head

6. `test_audit_text_shows_witness_signatures`:
   - Create PolicyHead with witness_signatures for "alice" and "bob"
   - Assert audit text contains "Signatures Collected: 2"
   - Assert audit text contains "alice:" and "bob:"

7. `test_audit_text_shows_submitter`:
   - Create PolicyHead with creator="admin:alice"
   - Assert audit text contains "Submitter: admin:alice"

8. `test_audit_text_deterministic`:
   - Create PolicyHead
   - Call policy_head_to_audit_text() twice
   - Assert both outputs are identical (same PolicyHead = same output)

9. `test_audit_text_witness_ids_sorted`:
   - Create PolicyHead with witness_signatures for "charlie", "alice", "bob" (unsorted)
   - Assert audit text shows witnesses in alphabetical order: alice, bob, charlie

Import policy_head_to_audit_text at top of file.
Use existing test fixtures (@pytest.fixture def test_chain).
Use T1, T2 time constants from test_utils.
  </action>
  <verify>
Run: `cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_policyhead.py::TestPolicyHeadAuditText -v`
  </verify>
  <done>
All 9 audit text tests pass, covering all AUD-01 requirements.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify full test suite passes</name>
  <files>tests/test_policyhead.py</files>
  <action>
Run the complete test suite to ensure:
1. All new audit text tests pass
2. All existing policyhead tests still pass
3. No regressions introduced

If any tests fail, debug and fix the implementation.
  </action>
  <verify>
Run: `cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_policyhead.py -v`
Expected: All tests pass (existing + new audit text tests)
  </verify>
  <done>
Full test_policyhead.py test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from decisiongraph.policyhead import policy_head_to_audit_text"` succeeds
2. `python -m pytest tests/test_policyhead.py::TestPolicyHeadAuditText -v` all pass
3. `python -m pytest tests/test_policyhead.py -v` all pass (no regressions)
</verification>

<success_criteria>
- policy_head_to_audit_text() function exists in policyhead.py
- Function exported via __all__
- Function produces deterministic human-readable output
- Output includes: namespace, cell_id, system_time, policy_hash, promoted_rule_ids, prev_policy_head, witness_signatures, submitter_id, schema_version
- 9 new tests validate all audit text requirements
- All existing policyhead tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-audit-trail/06-01-SUMMARY.md`
</output>
