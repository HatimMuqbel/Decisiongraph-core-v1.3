---
phase: 10-counterfactual-anchors
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/decisiongraph/anchors.py
autonomous: true

must_haves:
  truths:
    - "detect_counterfactual_anchors() returns minimal shadow components causing verdict delta"
    - "Execution bounded by max_anchor_attempts and max_runtime_ms"
    - "AnchorResult includes anchors_incomplete flag when budget exceeded"
    - "Anchor hash computed deterministically from sorted component IDs"
  artifacts:
    - path: "src/decisiongraph/anchors.py"
      provides: "Anchor detection module with ExecutionBudget, AnchorResult, detect_counterfactual_anchors"
      exports: ["ExecutionBudget", "AnchorResult", "detect_counterfactual_anchors", "compute_anchor_hash"]
  key_links:
    - from: "src/decisiongraph/anchors.py"
      to: "src/decisiongraph/simulation.py"
      via: "imports DeltaReport for verdict_changed check"
      pattern: "from .simulation import.*DeltaReport"
---

<objective>
Create the anchor detection module with bounded greedy ablation algorithm for identifying minimal shadow components causing verdict delta.

Purpose: CTF-02, CTF-03, CTF-04 require bounded anchor detection that identifies minimal changes causing outcome differences. This module provides the core algorithm and data structures.

Output: New src/decisiongraph/anchors.py module with ExecutionBudget class, AnchorResult frozen dataclass, detect_counterfactual_anchors() function, and compute_anchor_hash() helper.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-counterfactual-anchors/10-RESEARCH.md
@src/decisiongraph/simulation.py
@src/decisiongraph/engine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ExecutionBudget and AnchorResult Classes</name>
  <files>src/decisiongraph/anchors.py</files>
  <action>
Create new module src/decisiongraph/anchors.py with:

1. ExecutionBudget class (non-frozen, mutable tracker):
   - __init__(self, max_attempts: int, max_runtime_ms: int)
   - Store max_attempts, max_runtime_ms, attempts=0, start_time=time.time()
   - is_exceeded() -> bool: Check if attempts >= max_attempts OR elapsed_ms >= max_runtime_ms
   - increment(): Increment attempts counter
   - elapsed_ms() -> float: Return (time.time() - start_time) * 1000

2. AnchorResult frozen dataclass:
   - anchors: List[Tuple[str, str]]  # [(component_type, cell_id), ...]
   - anchors_incomplete: bool
   - attempts_used: int
   - runtime_ms: float
   - anchor_hash: str  # SHA-256 of sorted anchors
   - to_dict() method returning serializable dict

3. compute_anchor_hash() helper:
   - Takes List[Tuple[str, str]] anchors
   - Returns SHA-256 hash of sorted canonical JSON
   - Use json.dumps(sorted(anchors), sort_keys=True)

Module docstring should explain purpose (counterfactual anchor detection for identifying minimal shadow modifications causing verdict delta).

Imports needed: dataclasses (dataclass, field), typing (List, Tuple, Dict, Any), time, json, hashlib

Do NOT import Engine or simulation modules yet - those come in detect_counterfactual_anchors.
  </action>
  <verify>
python -c "from decisiongraph.anchors import ExecutionBudget, AnchorResult, compute_anchor_hash; print('Imports work')"
  </verify>
  <done>
ExecutionBudget tracks bounded execution (attempts + time). AnchorResult is frozen dataclass with anchors_incomplete flag. compute_anchor_hash returns deterministic SHA-256 hash.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement detect_counterfactual_anchors Function</name>
  <files>src/decisiongraph/anchors.py</files>
  <action>
Add detect_counterfactual_anchors() function to anchors.py:

```python
def detect_counterfactual_anchors(
    engine: 'Engine',
    rfa_dict: dict,
    base_result: dict,
    simulation_spec: dict,
    at_valid_time: str,
    as_of_system_time: str,
    max_anchor_attempts: int = 100,
    max_runtime_ms: int = 5000
) -> AnchorResult:
```

Algorithm (greedy iterative ablation):

1. Extract shadow component IDs from simulation_spec (sorted for determinism - CTF-01):
   - shadow_facts: sorted list of base_cell_id from simulation_spec['shadow_facts']
   - shadow_rules: sorted list of base_cell_id from simulation_spec['shadow_rules']
   - shadow_policy_heads: sorted list from simulation_spec['shadow_policy_heads']
   - shadow_bridges: sorted list from simulation_spec['shadow_bridges']

2. Combine into all_components: List[Tuple[str, str]] with format:
   - [('fact', cid), ('rule', cid), ('policy', cid), ('bridge', cid)]
   - Deterministic ordering: facts, then rules, then policy, then bridges

3. Edge case: If no components, return AnchorResult with empty anchors, anchors_incomplete=False

4. Create ExecutionBudget(max_anchor_attempts, max_runtime_ms)

5. Greedy search loop (largest to smallest subsets):
   - Start with minimal_anchor = all_components.copy()
   - For size from len(all_components)-1 down to 1:
     - Check budget.is_exceeded() - if True, return partial result with anchors_incomplete=True
     - For each subset of this size (use itertools.combinations):
       - Check budget.is_exceeded() again (inner loop can be long)
       - Build test_spec using _build_simulation_spec_from_subset()
       - Call engine.simulate_rfa() and budget.increment()
       - If test_result.delta_report.verdict_changed is True:
         - Update minimal_anchor = list(subset)
         - break (found smaller anchor, try even smaller)

6. Return AnchorResult with:
   - anchors: sorted(minimal_anchor)  # Final sort for determinism
   - anchors_incomplete: False (completed search)
   - attempts_used: budget.attempts
   - runtime_ms: budget.elapsed_ms()
   - anchor_hash: compute_anchor_hash(sorted(minimal_anchor))

Also add helper function _build_simulation_spec_from_subset():
- Takes original_spec and subset_components: List[Tuple[str, str]]
- Deep copies original_spec
- Filters each shadow_* list to only include components in subset
- Returns filtered spec

Forward reference: Use 'Engine' as string type hint (no circular import).

Add imports: import itertools, import copy, from typing import TYPE_CHECKING
Use TYPE_CHECKING block for Engine import hint.
  </action>
  <verify>
python -c "from decisiongraph.anchors import detect_counterfactual_anchors; print('Function imports')"
  </verify>
  <done>
detect_counterfactual_anchors() implements greedy ablation with ExecutionBudget bounds. Returns AnchorResult with anchors_incomplete=True when budget exceeded. Helper _build_simulation_spec_from_subset() filters spec to subset components.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add Module Exports and Unit Tests</name>
  <files>src/decisiongraph/anchors.py</files>
  <action>
1. Add __all__ export list to anchors.py:
   ```python
   __all__ = [
       'ExecutionBudget',
       'AnchorResult',
       'compute_anchor_hash',
       'detect_counterfactual_anchors'
   ]
   ```

2. Update src/decisiongraph/__init__.py to export from anchors:
   - Add imports: from .anchors import ExecutionBudget, AnchorResult, compute_anchor_hash, detect_counterfactual_anchors
   - Add to __all__ list

3. Run existing tests to verify no regressions:
   - pytest tests/ should pass (846 tests)

4. Verify module structure with basic import test:
   - python -c "from decisiongraph import ExecutionBudget, AnchorResult, compute_anchor_hash, detect_counterfactual_anchors"
  </action>
  <verify>
pytest tests/ -x -q 2>&1 | tail -20
python -c "from decisiongraph import ExecutionBudget, AnchorResult, compute_anchor_hash, detect_counterfactual_anchors; print('All exports work')"
  </verify>
  <done>
Module exports work via package __init__.py. All 846 existing tests pass (no regressions). ExecutionBudget, AnchorResult, compute_anchor_hash, detect_counterfactual_anchors all importable from decisiongraph package.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. src/decisiongraph/anchors.py exists with all required components
2. All 846 existing tests pass (no regressions)
3. New classes/functions importable from decisiongraph package
4. compute_anchor_hash produces deterministic output (same anchors = same hash)
5. ExecutionBudget correctly tracks attempts and elapsed time
</verification>

<success_criteria>
- [ ] ExecutionBudget class tracks max_attempts and max_runtime_ms bounds (CTF-02)
- [ ] AnchorResult frozen dataclass with anchors_incomplete field (CTF-04)
- [ ] detect_counterfactual_anchors() implements greedy ablation algorithm (CTF-03)
- [ ] compute_anchor_hash() produces deterministic SHA-256 hash (CTF-01 extension)
- [ ] _build_simulation_spec_from_subset() helper for subset filtering
- [ ] All 846 existing tests pass
- [ ] Module exports work via package __init__.py
</success_criteria>

<output>
After completion, create `.planning/phases/10-counterfactual-anchors/10-01-SUMMARY.md`
</output>
