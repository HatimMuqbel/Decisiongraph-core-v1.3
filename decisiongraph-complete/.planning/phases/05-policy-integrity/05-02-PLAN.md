---
phase: 05-policy-integrity
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/decisiongraph/engine.py
  - src/decisiongraph/policyhead.py
  - tests/test_policyhead.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "PolicyHead cell contains witness signatures that can be independently verified"
    - "verify_signature() can verify each witness signature in PolicyHead against canonical payload"
    - "PolicyHead audit trail includes who approved the promotion"
  artifacts:
    - path: "src/decisiongraph/policyhead.py"
      provides: "verify_policy_head_signatures function"
      exports: ["verify_policy_head_signatures"]
    - path: "src/decisiongraph/engine.py"
      provides: "Stores witness signatures in PolicyHead policy_data"
      contains: "witness_signatures"
    - path: "tests/test_policyhead.py"
      provides: "Tests for PolicyHead signature verification"
      min_lines: 400
  key_links:
    - from: "src/decisiongraph/engine.py:finalize_promotion"
      to: "create_policy_head"
      via: "Pass witness_signatures to policy_data"
      pattern: "witness_signatures.*promotion\\.signatures"
    - from: "src/decisiongraph/policyhead.py:verify_policy_head_signatures"
      to: "signing.verify_signature"
      via: "Verify each witness signature"
      pattern: "verify_signature"
---

<objective>
Store witness signatures in PolicyHead cells for audit trail (INT-01) and create verify_policy_head_signatures() function to enable independent verification of PolicyHead approvals.

Purpose: PolicyHead cells become self-contained audit records - anyone can verify that the required witnesses actually approved the promotion by checking signatures stored in the PolicyHead against the canonical payload.

Output: Modified create_policy_head() to accept witness_signatures, new verify_policy_head_signatures() function, tests proving signatures are stored and verifiable.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-policy-integrity/05-RESEARCH.md
@.planning/phases/05-policy-integrity/05-01-SUMMARY.md

# Source files to modify
@src/decisiongraph/engine.py
@src/decisiongraph/policyhead.py
@src/decisiongraph/signing.py
@tests/test_policyhead.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend create_policy_head() to store witness signatures</name>
  <files>src/decisiongraph/policyhead.py, src/decisiongraph/engine.py</files>
  <action>
**A) Modify create_policy_head() in policyhead.py:**

Add optional parameter `witness_signatures: Optional[Dict[str, bytes]] = None` to create_policy_head().

Store witness signatures in policy_data JSON:
```python
policy_data = {
    "policy_hash": policy_hash,
    "promoted_rule_ids": sorted_rule_ids,
    "prev_policy_head": prev_policy_head,
    "witness_signatures": {
        witness_id: base64.b64encode(sig).decode('ascii')
        for witness_id, sig in (witness_signatures or {}).items()
    } if witness_signatures else {}
}
```

Import base64 at top of file for encoding signatures to JSON-safe format.

Also add `canonical_payload: Optional[bytes] = None` parameter to store the payload that was signed. This enables verification without reconstructing the payload:
```python
policy_data = {
    "policy_hash": policy_hash,
    "promoted_rule_ids": sorted_rule_ids,
    "prev_policy_head": prev_policy_head,
    "witness_signatures": {...},
    "canonical_payload": base64.b64encode(canonical_payload).decode('ascii') if canonical_payload else None
}
```

**B) Modify finalize_promotion() in engine.py:**

Pass witness signatures and canonical payload to create_policy_head():
```python
policy_head = create_policy_head(
    namespace=promotion.namespace,
    promoted_rule_ids=list(promotion.rule_ids),
    graph_id=self.chain.graph_id,
    prev_cell_hash=self.chain.head.cell_id,
    prev_policy_head=prev_policy_head_id,
    system_time=get_current_timestamp(),
    creator=promotion.submitter_id,
    bootstrap_mode=True,
    witness_signatures=promotion.signatures,  # NEW
    canonical_payload=promotion.canonical_payload  # NEW
)
```

Update the import in engine.py if needed.
  </action>
  <verify>Run `pytest tests/test_engine_promotion.py -v` - existing finalization tests should still pass, PolicyHead now contains witness_signatures in policy_data</verify>
  <done>PolicyHead cells store witness signatures and canonical payload in policy_data JSON for audit trail</done>
</task>

<task type="auto">
  <name>Task 2: Create verify_policy_head_signatures() function</name>
  <files>src/decisiongraph/policyhead.py</files>
  <action>
Create a new function verify_policy_head_signatures() that verifies all witness signatures stored in a PolicyHead:

```python
def verify_policy_head_signatures(
    policy_head: DecisionCell,
    witness_public_keys: Dict[str, bytes]
) -> Tuple[bool, List[str]]:
    """
    Verify witness signatures stored in a PolicyHead cell.

    Each signature in the PolicyHead was made by a witness over the
    canonical_payload. This function verifies those signatures using
    the provided public keys.

    Args:
        policy_head: A DecisionCell with CellType.POLICY_HEAD
        witness_public_keys: Dict mapping witness_id -> Ed25519 public key (32 bytes)

    Returns:
        Tuple of (all_valid, error_messages)
        - all_valid: True if ALL signatures verify successfully
        - error_messages: List of errors (empty if all valid)

    Example:
        >>> is_valid, errors = verify_policy_head_signatures(
        ...     policy_head,
        ...     {"alice": alice_pub, "bob": bob_pub}
        ... )
        >>> if not is_valid:
        ...     for err in errors:
        ...         print(f"Signature error: {err}")
    """
    import base64
    from .signing import verify_signature

    errors = []

    # Parse policy data
    policy_data = parse_policy_data(policy_head)

    # Get witness signatures and canonical payload
    witness_sigs = policy_data.get("witness_signatures", {})
    canonical_payload_b64 = policy_data.get("canonical_payload")

    if not canonical_payload_b64:
        return (False, ["PolicyHead does not contain canonical_payload for verification"])

    # Decode canonical payload
    try:
        canonical_payload = base64.b64decode(canonical_payload_b64)
    except Exception as e:
        return (False, [f"Failed to decode canonical_payload: {e}"])

    if not witness_sigs:
        # No signatures to verify - could be bootstrap mode
        return (True, [])

    # Verify each signature
    for witness_id, sig_b64 in witness_sigs.items():
        # Get public key for this witness
        pub_key = witness_public_keys.get(witness_id)
        if pub_key is None:
            errors.append(f"No public key provided for witness '{witness_id}'")
            continue

        # Decode signature
        try:
            signature = base64.b64decode(sig_b64)
        except Exception as e:
            errors.append(f"Failed to decode signature for witness '{witness_id}': {e}")
            continue

        # Verify signature
        try:
            is_valid = verify_signature(pub_key, canonical_payload, signature)
            if not is_valid:
                errors.append(f"Signature verification failed for witness '{witness_id}'")
        except Exception as e:
            errors.append(f"Signature verification error for witness '{witness_id}': {e}")

    return (len(errors) == 0, errors)
```

Add to __all__ exports in policyhead.py:
```python
__all__ = [
    # ... existing exports ...
    'verify_policy_head_signatures',
]
```
  </action>
  <verify>Run `python -c "from decisiongraph.policyhead import verify_policy_head_signatures; print('Import OK')"` - function is importable</verify>
  <done>verify_policy_head_signatures() function exists and can verify witness signatures stored in PolicyHead cells</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for PolicyHead signature storage and verification</name>
  <files>tests/test_policyhead.py</files>
  <action>
Add new test class TestPolicyHeadSignatureVerification with tests:

**Storage Tests:**
1. test_policy_head_contains_witness_signatures - create PolicyHead with signatures, verify they are in policy_data
2. test_policy_head_contains_canonical_payload - verify canonical_payload is stored and base64 encoded
3. test_policy_head_signature_storage_empty_signatures - empty dict stored when no signatures

**Verification Tests:**
1. test_verify_policy_head_signatures_valid - create PolicyHead with valid signatures, verification returns (True, [])
2. test_verify_policy_head_signatures_invalid_signature - tampered signature returns (False, [error message])
3. test_verify_policy_head_signatures_missing_public_key - missing key returns error in list
4. test_verify_policy_head_signatures_no_signatures - empty signatures returns (True, [])
5. test_verify_policy_head_signatures_no_canonical_payload - missing payload returns error

**End-to-End Test:**
1. test_full_promotion_signatures_verifiable - run full promotion workflow via Engine, then verify PolicyHead signatures

Example test:
```python
class TestPolicyHeadSignatureVerification:
    """Tests for INT-01: PolicyHead signature verification"""

    def test_policy_head_contains_witness_signatures(self):
        """PolicyHead stores witness signatures in policy_data."""
        priv, pub = generate_ed25519_keypair()
        canonical_payload = b'{"test": "payload"}'
        signature = sign_bytes(priv, canonical_payload)

        policy_head = create_policy_head(
            namespace="corp",
            promoted_rule_ids=["rule:a"],
            graph_id="test-graph",
            prev_cell_hash="prev-hash",
            witness_signatures={"alice": signature},
            canonical_payload=canonical_payload
        )

        policy_data = parse_policy_data(policy_head)
        assert "witness_signatures" in policy_data
        assert "alice" in policy_data["witness_signatures"]
        assert "canonical_payload" in policy_data

    def test_verify_policy_head_signatures_valid(self):
        """Valid signatures verify successfully."""
        priv, pub = generate_ed25519_keypair()
        canonical_payload = b'{"test": "payload"}'
        signature = sign_bytes(priv, canonical_payload)

        policy_head = create_policy_head(
            namespace="corp",
            promoted_rule_ids=["rule:a"],
            graph_id="test-graph",
            prev_cell_hash="prev-hash",
            witness_signatures={"alice": signature},
            canonical_payload=canonical_payload
        )

        is_valid, errors = verify_policy_head_signatures(
            policy_head,
            {"alice": pub}
        )
        assert is_valid is True
        assert errors == []

    def test_verify_policy_head_signatures_invalid(self):
        """Invalid signature returns error."""
        priv, pub = generate_ed25519_keypair()
        wrong_priv, wrong_pub = generate_ed25519_keypair()
        canonical_payload = b'{"test": "payload"}'
        bad_signature = sign_bytes(wrong_priv, canonical_payload)

        policy_head = create_policy_head(
            namespace="corp",
            promoted_rule_ids=["rule:a"],
            graph_id="test-graph",
            prev_cell_hash="prev-hash",
            witness_signatures={"alice": bad_signature},
            canonical_payload=canonical_payload
        )

        is_valid, errors = verify_policy_head_signatures(
            policy_head,
            {"alice": pub}  # pub doesn't match wrong_priv
        )
        assert is_valid is False
        assert len(errors) == 1
        assert "alice" in errors[0]
```
  </action>
  <verify>Run `pytest tests/test_policyhead.py::TestPolicyHeadSignatureVerification -v` - all new tests pass</verify>
  <done>PolicyHead signature storage and verification have comprehensive test coverage</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pytest tests/test_policyhead.py -v` - all tests pass (existing + new)
2. `pytest tests/test_engine_promotion.py -v` - all tests pass (no regressions)
3. `pytest tests/ -v --tb=short` - no regressions in other test files
4. Verify INT-01: PolicyHead contains verifiable witness signatures
5. Verify audit trail: witness_signatures and canonical_payload stored in policy_data
</verification>

<success_criteria>
1. create_policy_head() accepts witness_signatures and canonical_payload parameters
2. PolicyHead policy_data contains witness_signatures (base64 encoded) and canonical_payload
3. verify_policy_head_signatures() successfully verifies valid signatures
4. verify_policy_head_signatures() returns errors for invalid signatures
5. finalize_promotion() passes witness signatures to create_policy_head()
6. All existing tests continue to pass (no regressions)
7. New tests cover signature storage, valid verification, and invalid verification cases
</success_criteria>

<output>
After completion, create `.planning/phases/05-policy-integrity/05-02-SUMMARY.md`
</output>
