---
phase: 07-shadow-cell-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/decisiongraph/shadow.py
  - tests/test_overlay_context.py
  - tests/test_contamination_prevention.py
autonomous: true

must_haves:
  truths:
    - "User can create OverlayContext and add shadow cells by type"
    - "OverlayContext provides deterministic lookup by fact key (namespace, subject, predicate)"
    - "Shadow chain is structurally separate from base chain (separate Chain instance)"
    - "Appending to shadow chain does NOT affect base chain (zero contamination)"
    - "User can verify no contamination via base chain length unchanged"
  artifacts:
    - path: "src/decisiongraph/shadow.py"
      provides: "OverlayContext container and fork_shadow_chain function"
      exports: ["OverlayContext", "fork_shadow_chain"]
      contains: "class OverlayContext"
    - path: "tests/test_overlay_context.py"
      provides: "OverlayContext tests"
      contains: "test_overlay_context_add_shadow_fact"
      min_lines: 80
    - path: "tests/test_contamination_prevention.py"
      provides: "Zero contamination structural tests"
      contains: "test_shadow_chain_append_no_base_contamination"
      min_lines: 60
  key_links:
    - from: "OverlayContext"
      to: "shadow_facts dict"
      via: "fact key indexing"
      pattern: "shadow_facts\\[.*\\]"
    - from: "fork_shadow_chain"
      to: "Chain"
      via: "separate instance creation"
      pattern: "Chain\\("
---

<objective>
Implement OverlayContext container and structural contamination prevention via separate Chain instances.

Purpose: OverlayContext holds shadow cells with deterministic precedence rules. Zero contamination is enforced structurally by using separate Chain instances - shadow cells can only be appended to shadow chain, never to base chain.

Output: OverlayContext class + fork_shadow_chain() function + contamination prevention tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-shadow-cell-foundation/07-RESEARCH.md
@src/decisiongraph/cell.py
@src/decisiongraph/chain.py
@src/decisiongraph/scholar.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OverlayContext class to shadow.py</name>
  <files>src/decisiongraph/shadow.py</files>
  <action>
Extend src/decisiongraph/shadow.py (created in 07-01 or create if running independently) with:

1. Additional imports:
   - from dataclasses import dataclass, field
   - from typing import Dict, List, Set, Tuple

2. OverlayContext dataclass:
   ```python
   @dataclass
   class OverlayContext:
       """
       Container for shadow cells with deterministic precedence rules.

       OverlayContext holds shadow cells indexed for efficient lookup during
       simulation. It is NOT a registry (no persistent storage) - it's a
       snapshot of hypothetical cells for a single simulation run.

       Precedence rule: When querying with OverlayContext, shadow cells
       override base cells for the same fact key. If no shadow exists for
       a key, the base cell is used.

       Attributes:
           shadow_facts: Dict mapping (namespace, subject, predicate) -> List[DecisionCell]
           shadow_rules: Dict mapping rule_id -> DecisionCell
           shadow_bridges: Dict mapping (source_ns, target_ns) -> DecisionCell
           shadow_policy_heads: Dict mapping namespace -> DecisionCell
           overridden_base_cells: Set of base cell_ids that have shadow overrides

       Usage:
           ctx = OverlayContext()
           ctx.add_shadow_fact(shadow_cell)
           facts = ctx.get_shadow_facts("corp.hr", "employee:alice", "salary")
       """
       shadow_facts: Dict[Tuple[str, str, str], List[DecisionCell]] = field(default_factory=dict)
       shadow_rules: Dict[str, DecisionCell] = field(default_factory=dict)
       shadow_bridges: Dict[Tuple[str, str], DecisionCell] = field(default_factory=dict)
       shadow_policy_heads: Dict[str, DecisionCell] = field(default_factory=dict)
       overridden_base_cells: Set[str] = field(default_factory=set)
   ```

3. OverlayContext methods:

   add_shadow_fact(self, cell: DecisionCell, base_cell_id: Optional[str] = None) -> None:
     - Key = (cell.fact.namespace, cell.fact.subject, cell.fact.predicate)
     - Append to shadow_facts[key] list (create if not exists)
     - If base_cell_id provided, add to overridden_base_cells

   add_shadow_rule(self, cell: DecisionCell, base_cell_id: Optional[str] = None) -> None:
     - Key = cell.logic_anchor.rule_id
     - Store in shadow_rules[key]
     - If base_cell_id provided, add to overridden_base_cells

   add_shadow_bridge(self, cell: DecisionCell, base_cell_id: Optional[str] = None) -> None:
     - Key = (cell.fact.subject, cell.fact.object) for bridge source/target
     - Store in shadow_bridges[key]
     - If base_cell_id provided, add to overridden_base_cells

   add_shadow_policy_head(self, cell: DecisionCell, base_cell_id: Optional[str] = None) -> None:
     - Key = cell.fact.namespace
     - Store in shadow_policy_heads[key]
     - If base_cell_id provided, add to overridden_base_cells

   get_shadow_facts(self, namespace: str, subject: str, predicate: str) -> List[DecisionCell]:
     - Return shadow_facts.get((namespace, subject, predicate), [])

   get_shadow_rule(self, rule_id: str) -> Optional[DecisionCell]:
     - Return shadow_rules.get(rule_id)

   get_shadow_bridge(self, source_ns: str, target_ns: str) -> Optional[DecisionCell]:
     - Return shadow_bridges.get((source_ns, target_ns))

   get_shadow_policy_head(self, namespace: str) -> Optional[DecisionCell]:
     - Return shadow_policy_heads.get(namespace)

   has_shadow_override(self, namespace: str, subject: str, predicate: str) -> bool:
     - Return (namespace, subject, predicate) in shadow_facts

   @classmethod
   from_shadow_cells(cls, shadow_cells: List[DecisionCell]) -> 'OverlayContext':
     - Factory method to create OverlayContext from list of shadow cells
     - Categorize by CellType and add to appropriate index
     - Follows pattern from 07-RESEARCH.md

4. Update __all__ to export OverlayContext
  </action>
  <verify>
Run: python -c "from decisiongraph.shadow import OverlayContext; ctx = OverlayContext(); print('OverlayContext OK')"
  </verify>
  <done>
OverlayContext class exists with add_shadow_* and get_shadow_* methods for facts, rules, bridges, and policy heads.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add fork_shadow_chain function for structural isolation</name>
  <files>src/decisiongraph/shadow.py</files>
  <action>
Add fork_shadow_chain() function to shadow.py:

1. Import Chain:
   - from .chain import Chain

2. Function implementation:
   ```python
   def fork_shadow_chain(base_chain: Chain) -> Chain:
       """
       Create a shadow chain as a structural copy of the base chain.

       This is the core contamination prevention mechanism. The shadow chain
       is a SEPARATE Chain instance that shares cell references with the base
       chain (memory-efficient) but has its own cells list and index.

       Structural isolation means:
       - shadow_chain.append() modifies shadow_chain.cells
       - base_chain.cells is NEVER modified by shadow operations
       - Impossible to contaminate base chain because it's a different object

       Args:
           base_chain: The production chain to fork from

       Returns:
           New Chain instance with shallow copy of cells and index

       Example:
           shadow_chain = fork_shadow_chain(base_chain)
           shadow_chain.append(shadow_cell)  # Only affects shadow_chain
           assert len(base_chain.cells) == original_length  # Base unchanged

       Note:
           Uses shallow copy of cells list - individual Cell objects are shared
           (they're immutable frozen dataclasses). Only the list container is new.
       """
       return Chain(
           cells=list(base_chain.cells),  # New list, shared cell references
           index=dict(base_chain.index),  # New dict, same mappings
           _graph_id=base_chain.graph_id,
           _root_namespace=base_chain.root_namespace
       )
   ```

3. Update __all__ to export fork_shadow_chain
  </action>
  <verify>
Run: python -c "from decisiongraph.shadow import fork_shadow_chain; from decisiongraph.chain import create_chain; c = create_chain(); s = fork_shadow_chain(c); print(f'Base: {len(c.cells)}, Shadow: {len(s.cells)}')"
Should output: "Base: 1, Shadow: 1" (both have genesis)
  </verify>
  <done>
fork_shadow_chain() function creates structurally separate Chain instance from base chain.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create OverlayContext tests</name>
  <files>tests/test_overlay_context.py</files>
  <action>
Create tests/test_overlay_context.py with:

1. Test fixtures:
   - create_test_fact_cell(namespace, subject, predicate, object_val)
   - create_test_rule_cell(rule_id)
   - create_test_bridge_cell(source_ns, target_ns)
   - create_test_policy_head_cell(namespace, rule_ids)

2. OverlayContext initialization tests:

   test_overlay_context_empty():
     - ctx = OverlayContext()
     - Assert all dicts empty
     - Assert overridden_base_cells empty

   test_overlay_context_add_shadow_fact():
     - Create shadow fact cell
     - ctx.add_shadow_fact(cell)
     - Assert ctx.get_shadow_facts(ns, subj, pred) returns [cell]

   test_overlay_context_add_shadow_fact_with_base_id():
     - ctx.add_shadow_fact(cell, base_cell_id="abc123")
     - Assert "abc123" in ctx.overridden_base_cells

   test_overlay_context_multiple_facts_same_key():
     - Add two shadow facts with same (ns, subj, pred)
     - Assert get_shadow_facts returns list of 2

   test_overlay_context_add_shadow_rule():
     - Create shadow rule cell
     - ctx.add_shadow_rule(cell)
     - Assert ctx.get_shadow_rule(rule_id) returns cell

   test_overlay_context_add_shadow_bridge():
     - Create shadow bridge cell
     - ctx.add_shadow_bridge(cell)
     - Assert ctx.get_shadow_bridge(src, tgt) returns cell

   test_overlay_context_add_shadow_policy_head():
     - Create shadow PolicyHead cell
     - ctx.add_shadow_policy_head(cell)
     - Assert ctx.get_shadow_policy_head(namespace) returns cell

   test_overlay_context_has_shadow_override():
     - Add shadow fact
     - Assert has_shadow_override(ns, subj, pred) is True
     - Assert has_shadow_override(other_ns, subj, pred) is False

   test_overlay_context_from_shadow_cells():
     - Create list with fact, rule, bridge, policy_head cells
     - ctx = OverlayContext.from_shadow_cells(cells)
     - Assert each type indexed correctly

   test_overlay_context_get_nonexistent_returns_empty():
     - ctx = OverlayContext()
     - Assert get_shadow_facts returns []
     - Assert get_shadow_rule returns None
     - Assert get_shadow_bridge returns None
     - Assert get_shadow_policy_head returns None
  </action>
  <verify>
Run: cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_overlay_context.py -v
All tests pass.
  </verify>
  <done>
tests/test_overlay_context.py exists with 10+ test cases covering OverlayContext add/get operations, multi-value keys, and factory method. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create contamination prevention tests</name>
  <files>tests/test_contamination_prevention.py</files>
  <action>
Create tests/test_contamination_prevention.py with critical tests for SHD-04:

1. Core contamination prevention tests:

   test_shadow_chain_append_no_base_contamination():
     - base_chain = create_chain()
     - original_length = len(base_chain.cells)
     - shadow_chain = fork_shadow_chain(base_chain)
     - Create and append a new cell to shadow_chain
     - Assert len(base_chain.cells) == original_length
     - Assert len(shadow_chain.cells) == original_length + 1

   test_shadow_chain_separate_index():
     - base_chain = create_chain()
     - shadow_chain = fork_shadow_chain(base_chain)
     - Append cell to shadow_chain
     - Assert new cell_id in shadow_chain.index
     - Assert new cell_id NOT in base_chain.index

   test_shadow_chain_shares_cell_references():
     - base_chain with multiple cells
     - shadow_chain = fork_shadow_chain(base_chain)
     - Assert shadow_chain.cells[0] is base_chain.cells[0] (same object)
     - Memory efficiency: shared immutable cell references

   test_shadow_chain_graph_id_match():
     - shadow_chain = fork_shadow_chain(base_chain)
     - Assert shadow_chain.graph_id == base_chain.graph_id
     - Shadow cells can be appended (same graph_id)

   test_multiple_shadow_chains_isolated():
     - shadow1 = fork_shadow_chain(base_chain)
     - shadow2 = fork_shadow_chain(base_chain)
     - Append cell to shadow1
     - Assert len(base_chain.cells) == 1
     - Assert len(shadow1.cells) == 2
     - Assert len(shadow2.cells) == 1
     - Each shadow is isolated from base and from each other

   test_base_chain_head_unchanged():
     - base_chain = create_chain()
     - original_head_id = base_chain.head.cell_id
     - shadow_chain = fork_shadow_chain(base_chain)
     - Append multiple cells to shadow_chain
     - Assert base_chain.head.cell_id == original_head_id

   test_shadow_chain_validates_cells():
     - shadow_chain = fork_shadow_chain(base_chain)
     - shadow_chain.append() should still validate integrity
     - Create cell with wrong graph_id
     - Assert raises GraphIdMismatch (normal chain validation)

2. Integration test:

   test_full_simulation_flow_no_contamination():
     - Create base_chain with genesis + 3 fact cells
     - original_length = len(base_chain.cells)
     - shadow_chain = fork_shadow_chain(base_chain)
     - Create OverlayContext, add shadow facts
     - Inject shadow facts into shadow_chain (append)
     - Query shadow_chain for facts
     - Assert len(base_chain.cells) == original_length (CRITICAL)
     - Assert shadow facts accessible in shadow_chain
     - Assert base chain unmodified
  </action>
  <verify>
Run: cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_contamination_prevention.py -v
All tests pass.
  </verify>
  <done>
tests/test_contamination_prevention.py exists with 8+ test cases proving structural isolation and zero contamination. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 5: Update exports and run full test suite</name>
  <files>src/decisiongraph/__init__.py</files>
  <action>
1. Update src/decisiongraph/__init__.py to export OverlayContext and fork_shadow_chain:
   - Add to imports from .shadow
   - Add to __all__ list

2. Verify module structure:
   - All shadow.py exports accessible from decisiongraph package

3. Run full test suite to verify no regressions:
   - All 753 existing tests must pass
   - All new tests must pass (shadow cells + overlay context + contamination)
  </action>
  <verify>
Run: cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/ -v --tb=short 2>&1 | tail -20
Verify: All tests pass (should show 753 + new tests)
  </verify>
  <done>
OverlayContext and fork_shadow_chain exported from decisiongraph package. Full test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. OverlayContext verification:
   ```python
   from decisiongraph import OverlayContext
   ctx = OverlayContext()
   # Should have empty dicts for shadow_facts, shadow_rules, etc.
   assert ctx.shadow_facts == {}
   ```

2. Zero contamination verification (CRITICAL for SHD-04):
   ```python
   from decisiongraph import create_chain
   from decisiongraph.shadow import fork_shadow_chain

   base = create_chain()
   original_len = len(base.cells)

   shadow = fork_shadow_chain(base)
   # Simulate appending shadow cells...
   # shadow.append(some_cell)

   assert len(base.cells) == original_len, "CONTAMINATION DETECTED!"
   ```

3. Test count verification:
   ```bash
   pytest tests/ --collect-only | grep "test session starts" -A1
   ```
   Should show 753+ tests collected
</verification>

<success_criteria>
- [ ] OverlayContext class exists with add/get methods for all shadow types
- [ ] fork_shadow_chain() creates structurally separate Chain instance
- [ ] Appending to shadow chain does NOT modify base chain (zero contamination)
- [ ] OverlayContext tests pass (10+ test cases)
- [ ] Contamination prevention tests pass (8+ test cases)
- [ ] All 753 existing tests pass (no regressions)
- [ ] OverlayContext and fork_shadow_chain exported from decisiongraph package
</success_criteria>

<output>
After completion, create `.planning/phases/07-shadow-cell-foundation/07-02-SUMMARY.md`
</output>
