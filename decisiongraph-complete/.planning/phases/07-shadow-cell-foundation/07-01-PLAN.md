---
phase: 07-shadow-cell-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/decisiongraph/shadow.py
  - tests/test_shadow_cells.py
autonomous: true

must_haves:
  truths:
    - "User can create shadow variant of any DecisionCell using create_shadow_cell()"
    - "Shadow cells have distinct cell_id from base cells (content changed = different hash)"
    - "Base cell remains unchanged after creating shadow variant (immutability preserved)"
    - "Shadow cells are valid DecisionCells passing verify_integrity()"
  artifacts:
    - path: "src/decisiongraph/shadow.py"
      provides: "Shadow cell creation functions"
      exports: ["create_shadow_cell", "create_shadow_fact", "create_shadow_rule", "create_shadow_policy_head", "create_shadow_bridge"]
      min_lines: 80
    - path: "tests/test_shadow_cells.py"
      provides: "Shadow cell creation tests"
      contains: "test_shadow_cell_distinct_id"
      min_lines: 100
  key_links:
    - from: "src/decisiongraph/shadow.py"
      to: "dataclasses.replace"
      via: "import and function call"
      pattern: "from dataclasses import replace"
    - from: "src/decisiongraph/shadow.py"
      to: "src/decisiongraph/cell.py"
      via: "DecisionCell import"
      pattern: "from .cell import DecisionCell"
---

<objective>
Implement shadow cell creation functions using dataclasses.replace().

Purpose: Shadow cells are the foundation of Oracle layer simulation. Users need to create hypothetical variants of real cells (facts, rules, policies, bridges) without mutating originals.

Output: src/decisiongraph/shadow.py with creation functions + comprehensive tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-shadow-cell-foundation/07-RESEARCH.md
@src/decisiongraph/cell.py
@src/decisiongraph/policyhead.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shadow.py with shadow cell creation functions</name>
  <files>src/decisiongraph/shadow.py</files>
  <action>
Create src/decisiongraph/shadow.py with the following:

1. Module docstring explaining shadow cells are hypothetical variants created via dataclasses.replace()

2. Imports:
   - from dataclasses import replace
   - from typing import Optional, Any, Dict
   - from .cell import DecisionCell, CellType, Fact, Header, LogicAnchor

3. Core function create_shadow_cell():
   ```python
   def create_shadow_cell(
       base_cell: DecisionCell,
       fact: Optional[Fact] = None,
       header: Optional[Header] = None,
       logic_anchor: Optional[LogicAnchor] = None
   ) -> DecisionCell:
       """
       Create a shadow variant of a DecisionCell using dataclasses.replace().

       Shadow cells are hypothetical variants used for simulation.
       The cell_id is automatically recomputed in __post_init__ based on
       modified content, ensuring shadow cells have distinct identities.

       Args:
           base_cell: The original cell to create a shadow from
           fact: Optional replacement Fact (nested replace if modifying fields)
           header: Optional replacement Header
           logic_anchor: Optional replacement LogicAnchor

       Returns:
           New DecisionCell with replaced fields and recomputed cell_id

       Note:
           - Base cell is NEVER modified (frozen dataclass)
           - Shadow cell has DIFFERENT cell_id if any content changed
           - cell_id field is init=False, so replace() triggers __post_init__
       """
   ```
   Implementation: Use dataclasses.replace() with only non-None kwargs

4. Convenience functions (each calls create_shadow_cell internally):

   - create_shadow_fact(base_cell, object=None, confidence=None, valid_from=None, valid_to=None) -> DecisionCell
     For modifying fact.object value (most common shadow case)

   - create_shadow_rule(base_cell, rule_logic_hash=None) -> DecisionCell
     For hypothetical rule changes (different logic hash)

   - create_shadow_policy_head(base_cell, promoted_rule_ids=None) -> DecisionCell
     For "what if these rules were promoted?" - recomputes policy_hash

   - create_shadow_bridge(base_cell, object=None) -> DecisionCell
     For bridge rule modifications (target namespace changes)

5. Helper function for nested Fact replacement:
   ```python
   def _replace_fact_fields(base_fact: Fact, **kwargs) -> Fact:
       """Replace specific fields in a Fact using dataclasses.replace()."""
       # Filter out None values
       non_none_kwargs = {k: v for k, v in kwargs.items() if v is not None}
       if not non_none_kwargs:
           return base_fact
       return replace(base_fact, **non_none_kwargs)
   ```

6. __all__ export list with all public functions

Key patterns from research (07-RESEARCH.md):
- Use replace(base_cell, fact=replace(base_cell.fact, object="new_value")) for nested fields
- cell_id is init=False so it's excluded from replace() and recomputed in __post_init__
- NEVER pass cell_id to replace() - it will raise TypeError
- For PolicyHead shadow, recompute policy_hash from new promoted_rule_ids
  </action>
  <verify>
Run: python -c "from decisiongraph.shadow import create_shadow_cell, create_shadow_fact; print('Import OK')"
Verify module loads without errors.
  </verify>
  <done>
shadow.py exists with create_shadow_cell(), create_shadow_fact(), create_shadow_rule(), create_shadow_policy_head(), create_shadow_bridge() functions exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive shadow cell tests</name>
  <files>tests/test_shadow_cells.py</files>
  <action>
Create tests/test_shadow_cells.py with the following test cases:

1. Test setup fixtures:
   - create_base_fact_cell() - creates a standard fact cell for testing
   - create_base_rule_cell() - creates a rule cell
   - create_base_policy_head() - creates a PolicyHead cell
   - create_base_bridge_cell() - creates a bridge cell
   - Use frozen timestamps for determinism (e.g., "2026-01-28T10:00:00Z")

2. Core shadow cell tests:

   test_shadow_cell_distinct_id():
     - Create base cell
     - Create shadow with modified fact.object
     - Assert shadow.cell_id != base.cell_id
     - Assert shadow.fact.object == new value
     - Assert base.fact.object == original value (immutability)

   test_shadow_cell_base_unchanged():
     - Create base cell, store original cell_id
     - Create shadow
     - Assert base.cell_id == original_cell_id
     - Assert base.verify_integrity() is True

   test_shadow_cell_valid_integrity():
     - Create shadow cell
     - Assert shadow.verify_integrity() is True

   test_shadow_cell_no_modification_same_id():
     - Create shadow with no changes (all kwargs None)
     - Assert shadow.cell_id == base.cell_id (content identical)

   test_shadow_fact_convenience():
     - Use create_shadow_fact(base, object="90000")
     - Assert shadow.fact.object == "90000"
     - Assert shadow.cell_id != base.cell_id

   test_shadow_fact_confidence():
     - Use create_shadow_fact(base, confidence=0.9)
     - Assert shadow.fact.confidence == 0.9

   test_shadow_rule_logic_hash():
     - Use create_shadow_rule(base, rule_logic_hash="new_hash")
     - Assert shadow.logic_anchor.rule_logic_hash == "new_hash"
     - Assert shadow.cell_id != base.cell_id

   test_shadow_policy_head_new_rules():
     - Use create_shadow_policy_head(base, promoted_rule_ids=["rule:new_v1"])
     - Parse shadow.fact.object as JSON
     - Assert promoted_rule_ids == ["rule:new_v1"]
     - Assert policy_hash matches compute_policy_hash(["rule:new_v1"])

   test_shadow_bridge_target():
     - Use create_shadow_bridge(base, object="new_target_ns")
     - Assert shadow.fact.object == "new_target_ns"

3. Edge case tests:

   test_shadow_cell_preserves_evidence():
     - Base cell with evidence list
     - Shadow cell preserves evidence (not modified)

   test_shadow_cell_preserves_proof():
     - Base cell with proof data
     - Shadow cell preserves proof (not modified)

   test_multiple_shadows_from_same_base():
     - Create base, then shadow1, shadow2 with different modifications
     - Assert all three have different cell_ids
     - Assert base unchanged after both shadows

4. Run all tests with pytest:
   - Use standard pytest conventions
   - Import from decisiongraph.shadow, decisiongraph.cell, decisiongraph.policyhead
  </action>
  <verify>
Run: cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_shadow_cells.py -v
All tests pass.
  </verify>
  <done>
tests/test_shadow_cells.py exists with 10+ test cases covering shadow cell creation, immutability preservation, distinct cell_ids, and edge cases. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update __init__.py exports and run full test suite</name>
  <files>src/decisiongraph/__init__.py</files>
  <action>
1. Update src/decisiongraph/__init__.py to export shadow module functions:
   - Add imports: from .shadow import (create_shadow_cell, create_shadow_fact, create_shadow_rule, create_shadow_policy_head, create_shadow_bridge)
   - Add to __all__ list

2. Run full test suite to verify no regressions:
   - All 753 existing tests must pass
   - All new shadow cell tests must pass
  </action>
  <verify>
Run: cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/ -v --tb=short
Verify: All tests pass (753 existing + new shadow tests)
  </verify>
  <done>
Shadow cell functions exported from decisiongraph package. Full test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Import verification:
   ```python
   from decisiongraph import create_shadow_cell, create_shadow_fact
   from decisiongraph.shadow import create_shadow_policy_head
   ```

2. Functionality verification:
   ```python
   from decisiongraph import create_shadow_fact
   from decisiongraph.cell import DecisionCell, Header, Fact, LogicAnchor, CellType, SourceQuality

   # Create base cell
   base = DecisionCell(
       header=Header(version="1.3", graph_id="graph:test", cell_type=CellType.FACT,
                     system_time="2026-01-28T10:00:00Z", prev_cell_hash="0"*64),
       fact=Fact(namespace="corp.hr", subject="employee:alice", predicate="salary",
                 object="80000", confidence=1.0, source_quality=SourceQuality.VERIFIED),
       logic_anchor=LogicAnchor(rule_id="rule:salary_v1", rule_logic_hash="abc123")
   )

   # Create shadow
   shadow = create_shadow_fact(base, object="90000")

   assert shadow.cell_id != base.cell_id  # Different content = different hash
   assert shadow.fact.object == "90000"    # Modified value
   assert base.fact.object == "80000"      # Original unchanged
   ```

3. Test count: `pytest tests/ --collect-only | grep "test session starts" -A1`
   - Should show 753+ tests collected
</verification>

<success_criteria>
- [ ] src/decisiongraph/shadow.py exists with create_shadow_cell and convenience functions
- [ ] Shadow cells have distinct cell_id when content changes
- [ ] Base cells remain unchanged (immutability verified)
- [ ] Shadow cells pass verify_integrity()
- [ ] All 753 existing tests pass (no regressions)
- [ ] New shadow cell tests pass
- [ ] Functions exported from decisiongraph package
</success_criteria>

<output>
After completion, create `.planning/phases/07-shadow-cell-foundation/07-01-SUMMARY.md`
</output>
