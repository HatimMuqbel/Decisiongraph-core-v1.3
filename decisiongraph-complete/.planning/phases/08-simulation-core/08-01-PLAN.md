---
phase: 08-simulation-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/decisiongraph/simulation.py
  - src/decisiongraph/__init__.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "SimulationContext can be used as context manager (with statement)"
    - "SimulationContext creates shadow chain from base chain on enter"
    - "SimulationContext appends shadow cells from OverlayContext to shadow chain"
    - "SimulationContext cleans up shadow chain on exit (even on exception)"
    - "SimulationResult is immutable (frozen dataclass)"
    - "SimulationResult contains base_result, shadow_result, and coordinates"
  artifacts:
    - path: "src/decisiongraph/simulation.py"
      provides: "SimulationContext context manager and SimulationResult dataclass"
      min_lines: 100
      exports: ["SimulationContext", "SimulationResult"]
  key_links:
    - from: "src/decisiongraph/simulation.py"
      to: "src/decisiongraph/shadow.py"
      via: "import fork_shadow_chain, OverlayContext"
      pattern: "from \\.shadow import.*fork_shadow_chain"
    - from: "src/decisiongraph/simulation.py"
      to: "src/decisiongraph/scholar.py"
      via: "import create_scholar"
      pattern: "from \\.scholar import.*create_scholar"
    - from: "SimulationContext.__enter__"
      to: "OverlayContext shadow cells"
      via: "append shadow cells to shadow_chain before create_scholar"
      pattern: "shadow_chain\\.append"
---

<objective>
Create SimulationContext context manager and SimulationResult frozen dataclass - the core building blocks for safe simulation with guaranteed cleanup.

Purpose: These components enable safe "what-if" simulation without contaminating the base chain. Context manager ensures shadow resources are always cleaned up (even on exception). Frozen result ensures simulation outputs are immutable.

Output: `src/decisiongraph/simulation.py` module with SimulationContext and SimulationResult exported via `__init__.py`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-simulation-core/08-RESEARCH.md
@.planning/phases/07-shadow-cell-foundation/07-02-SUMMARY.md
@src/decisiongraph/shadow.py
@src/decisiongraph/scholar.py
@src/decisiongraph/chain.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: SimulationContext context manager</name>
  <files>src/decisiongraph/simulation.py</files>
  <action>
Create new module `src/decisiongraph/simulation.py` with SimulationContext class implementing context manager protocol.

SimulationContext requirements:
- `__init__(self, base_chain, overlay_context, at_valid_time, as_of_system_time)`:
  - Store all parameters as instance attributes
  - Initialize `shadow_chain = None` and `shadow_scholar = None`

- `__enter__(self)`:
  1. Fork chain: `self.shadow_chain = fork_shadow_chain(self.base_chain)`
  2. **CRITICAL - Apply shadow cells from OverlayContext to shadow_chain:**
     ```python
     # Append shadow facts (for each base_cell_id, append all shadow variants)
     for fact_cells in self.overlay_context.shadow_facts.values():
         for cell in fact_cells:
             self.shadow_chain.append(cell)

     # Append shadow rules
     for rule_cell in self.overlay_context.shadow_rules.values():
         self.shadow_chain.append(rule_cell)

     # Append shadow policy heads
     for policy_cell in self.overlay_context.shadow_policy_heads.values():
         self.shadow_chain.append(policy_cell)

     # Append shadow bridges
     for bridge_cell in self.overlay_context.shadow_bridges.values():
         self.shadow_chain.append(bridge_cell)
     ```
  3. Create shadow scholar AFTER shadow cells are appended:
     `self.shadow_scholar = create_scholar(self.shadow_chain)`
  4. Return `self` (context object for use in with block)

  **Why this order matters (SIM-03):** Scholar queries the chain it's given. By appending
  shadow cells to shadow_chain BEFORE creating shadow_scholar, the Scholar will see
  shadow cells during query. Shadow cells have is_shadow=True flag, allowing precedence
  logic to prefer shadow over base when same key matches.

- `__exit__(self, exc_type, exc_value, exc_traceback)`:
  - Set `self.shadow_chain = None` (cleanup)
  - Set `self.shadow_scholar = None` (cleanup)
  - Return `False` (do NOT suppress exceptions - propagate them)

- Property `at_valid_time` and `as_of_system_time` for accessing frozen coordinates

Import from existing modules:
- `from .shadow import fork_shadow_chain, OverlayContext`
- `from .scholar import create_scholar, Scholar`
- `from .chain import Chain`

Include module docstring explaining:
- Purpose: Safe simulation with guaranteed cleanup
- Context manager pattern: `with SimulationContext(...) as ctx:`
- Cleanup guarantee: shadow resources discarded even on exception
- Phase 7 foundation: Uses fork_shadow_chain for structural isolation
- Shadow cell injection: OverlayContext cells appended to shadow_chain in __enter__
  </action>
  <verify>
```python
# Quick verification in Python REPL:
from decisiongraph.simulation import SimulationContext
from decisiongraph import create_chain, create_fact_cell, create_rule_cell
from decisiongraph.shadow import OverlayContext, create_shadow_fact

# Create minimal test setup
chain = create_chain("test_graph", "test_ns")

# Add a rule and fact to base chain
rule = create_rule_cell("test_ns", "rule:r1", "defines", "test", "rule:r1", "hash", "test_graph", chain.head.cell_id)
chain.append(rule)
fact = create_fact_cell("test_ns", "subj", "pred", "base_value", "rule:r1", "test_graph", chain.head.cell_id)
chain.append(fact)

# Create OverlayContext with shadow fact
ctx = OverlayContext()
shadow_fact = create_shadow_fact(fact, object="shadow_value")
ctx.add_shadow_fact(shadow_fact, fact.cell_id)

# Test context manager
sim = SimulationContext(chain, ctx, "2025-01-01T00:00:00Z", "2025-01-01T00:00:00Z")

with sim as active_ctx:
    assert active_ctx.shadow_chain is not None
    assert active_ctx.shadow_scholar is not None
    # Verify shadow cell was appended to shadow_chain
    shadow_cells = [c for c in active_ctx.shadow_chain.cells if getattr(c.fact, 'is_shadow', False)]
    assert len(shadow_cells) >= 1, "Shadow cell not appended to shadow_chain"

# After exit
assert sim.shadow_chain is None
assert sim.shadow_scholar is None
print("OK: SimulationContext appends shadow cells correctly")
```
  </verify>
  <done>SimulationContext class exists with __init__, __enter__, __exit__ implementing context manager protocol. Shadow chain created on enter, shadow cells from OverlayContext appended to shadow_chain, shadow_scholar created with shadow cells visible, cleaned up on exit.</done>
</task>

<task type="auto">
  <name>Task 2: SimulationResult frozen dataclass</name>
  <files>src/decisiongraph/simulation.py, src/decisiongraph/__init__.py</files>
  <action>
Add SimulationResult frozen dataclass to `simulation.py`:

```python
from dataclasses import dataclass, field
from typing import Dict, Any, Optional

@dataclass(frozen=True)
class SimulationResult:
    """
    Immutable simulation result.

    Contains base and shadow query results along with simulation metadata.
    Frozen dataclass ensures results cannot be modified after creation.
    """
    simulation_id: str
    rfa_dict: Dict[str, Any]
    simulation_spec: Dict[str, Any]
    base_result: Dict[str, Any]    # proof_bundle from base query
    shadow_result: Dict[str, Any]  # proof_bundle from shadow query
    at_valid_time: str
    as_of_system_time: str

    def to_dict(self) -> Dict[str, Any]:
        """Convert to serializable dict."""
        return {
            "simulation_id": self.simulation_id,
            "rfa_dict": self.rfa_dict,
            "simulation_spec": self.simulation_spec,
            "base_result": self.base_result,
            "shadow_result": self.shadow_result,
            "at_valid_time": self.at_valid_time,
            "as_of_system_time": self.as_of_system_time
        }
```

Update `src/decisiongraph/__init__.py`:
- Add import: `from .simulation import SimulationContext, SimulationResult`
- Add to `__all__`: `'SimulationContext'`, `'SimulationResult'`

Add `__all__` to simulation.py:
```python
__all__ = [
    'SimulationContext',
    'SimulationResult',
]
```
  </action>
  <verify>
```bash
# Verify frozen behavior
python3 -c "
from decisiongraph import SimulationResult
result = SimulationResult(
    simulation_id='test-123',
    rfa_dict={'namespace': 'test'},
    simulation_spec={},
    base_result={},
    shadow_result={},
    at_valid_time='2025-01-01T00:00:00Z',
    as_of_system_time='2025-01-01T00:00:00Z'
)
# Verify frozen
try:
    result.simulation_id = 'modified'
    print('ERROR: Should have raised FrozenInstanceError')
except Exception as e:
    print(f'OK: Modification blocked with {type(e).__name__}')

# Verify to_dict
d = result.to_dict()
assert d['simulation_id'] == 'test-123'
print('OK: to_dict works')
"
```
  </verify>
  <done>SimulationResult frozen dataclass exists with all required fields and to_dict method. Exported from decisiongraph package. Modification attempts raise FrozenInstanceError.</done>
</task>

</tasks>

<verification>
All checks must pass:

1. Module exists and imports correctly:
   ```bash
   python3 -c "from decisiongraph.simulation import SimulationContext, SimulationResult; print('OK')"
   ```

2. Package exports work:
   ```bash
   python3 -c "from decisiongraph import SimulationContext, SimulationResult; print('OK')"
   ```

3. Context manager protocol works AND shadow cells are appended:
   ```bash
   python3 -c "
   from decisiongraph import create_chain, create_fact_cell, create_rule_cell
   from decisiongraph.simulation import SimulationContext
   from decisiongraph.shadow import OverlayContext, create_shadow_fact

   chain = create_chain('g', 'ns')
   rule = create_rule_cell('ns', 'rule:r1', 'def', 'test', 'rule:r1', 'h', 'g', chain.head.cell_id)
   chain.append(rule)
   fact = create_fact_cell('ns', 's', 'p', 'base', 'rule:r1', 'g', chain.head.cell_id)
   chain.append(fact)

   ctx = OverlayContext()
   shadow = create_shadow_fact(fact, object='shadow')
   ctx.add_shadow_fact(shadow, fact.cell_id)

   sim = SimulationContext(chain, ctx, '2025-01-01T00:00:00Z', '2025-01-01T00:00:00Z')

   with sim as s:
       assert s.shadow_chain is not None
       assert s.shadow_scholar is not None
       # Verify shadow cell appended
       shadow_cells = [c for c in s.shadow_chain.cells if getattr(c.fact, 'is_shadow', False)]
       assert len(shadow_cells) >= 1, 'Shadow cell not appended!'

   assert sim.shadow_chain is None
   print('Context manager OK - shadow cells appended')
   "
   ```

4. SimulationResult is frozen:
   ```bash
   python3 -c "
   from decisiongraph import SimulationResult
   r = SimulationResult('id', {}, {}, {}, {}, 't1', 't2')
   try:
       r.simulation_id = 'x'
       exit(1)
   except:
       print('Frozen OK')
   "
   ```

5. All existing tests still pass:
   ```bash
   cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/ -q
   ```
</verification>

<success_criteria>
- [ ] `src/decisiongraph/simulation.py` created with SimulationContext and SimulationResult
- [ ] SimulationContext implements `__enter__` and `__exit__` correctly
- [ ] SimulationContext creates shadow chain on enter
- [ ] **SimulationContext appends shadow cells from OverlayContext to shadow_chain in __enter__**
- [ ] SimulationContext creates shadow_scholar AFTER shadow cells appended (so Scholar sees them)
- [ ] SimulationContext cleans up on exit
- [ ] SimulationResult is frozen dataclass with all required fields
- [ ] SimulationResult has to_dict() method
- [ ] Both classes exported from decisiongraph package
- [ ] All 795 existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/08-simulation-core/08-01-SUMMARY.md`
</output>
