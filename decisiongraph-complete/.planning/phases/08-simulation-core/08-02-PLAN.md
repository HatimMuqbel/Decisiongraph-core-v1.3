---
phase: 08-simulation-core
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/decisiongraph/engine.py
  - tests/test_simulation.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can call engine.simulate_rfa() with RFA, simulation_spec, and bitemporal coordinates"
    - "Base reality is queried at frozen coordinates before any shadow operations"
    - "Shadow overlay injection uses OverlayContext with deterministic precedence"
    - "Context manager ensures shadow chain cleanup after simulation"
    - "SimulationResult contains both base_result and shadow_result"
  artifacts:
    - path: "src/decisiongraph/engine.py"
      provides: "Engine.simulate_rfa() method"
      contains: "def simulate_rfa"
    - path: "tests/test_simulation.py"
      provides: "Simulation integration tests"
      min_lines: 200
      contains: "test_simulate_rfa"
  key_links:
    - from: "src/decisiongraph/engine.py"
      to: "src/decisiongraph/simulation.py"
      via: "import SimulationContext, SimulationResult"
      pattern: "from \\.simulation import"
    - from: "src/decisiongraph/engine.py"
      to: "src/decisiongraph/shadow.py"
      via: "OverlayContext for shadow cell management"
      pattern: "OverlayContext"
---

<objective>
Implement Engine.simulate_rfa() method and comprehensive simulation tests - the user-facing entry point for "what-if" analysis.

Purpose: This is the core simulation API that external developers will call. It orchestrates base query, shadow overlay, shadow query, and result packaging while ensuring zero contamination via context manager cleanup.

Output: Engine.simulate_rfa() method in `engine.py` and comprehensive tests in `test_simulation.py`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-simulation-core/08-RESEARCH.md
@.planning/phases/08-simulation-core/08-01-SUMMARY.md
@src/decisiongraph/engine.py
@src/decisiongraph/simulation.py
@src/decisiongraph/shadow.py
@src/decisiongraph/scholar.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Engine.simulate_rfa() method</name>
  <files>src/decisiongraph/engine.py</files>
  <action>
Add `simulate_rfa()` method to Engine class in `engine.py`.

Add imports at top of file:
```python
from .simulation import SimulationContext, SimulationResult
from .shadow import OverlayContext, create_shadow_fact, create_shadow_rule, create_shadow_policy_head, create_shadow_bridge
```

Add method to Engine class:
```python
def simulate_rfa(
    self,
    rfa_dict: dict,
    simulation_spec: dict,
    at_valid_time: str,
    as_of_system_time: str
) -> SimulationResult:
    """
    Simulate an RFA against shadow reality (SIM-01, SIM-02, SIM-03, SHD-05).

    Creates an isolated "what-if" scenario by:
    1. Freezing base reality at specified bitemporal coordinates (SIM-02, SHD-05)
    2. Building OverlayContext from simulation_spec shadow cells
    3. Running shadow query with deterministic precedence (SIM-03)
    4. Returning immutable SimulationResult with base/shadow comparison

    Zero contamination guaranteed: context manager ensures shadow chain
    cleanup even on exception. Base chain is NEVER modified.

    Args:
        rfa_dict: Request-For-Access to simulate (same format as process_rfa)
        simulation_spec: Shadow cells to inject, dict with keys:
            - shadow_facts: List[dict] with {base_cell_id, modifications}
            - shadow_rules: List[dict] with {base_cell_id, modifications}
            - shadow_policy_heads: List[dict] with {base_cell_id, modifications}
            - shadow_bridges: List[dict] with {base_cell_id, modifications}
        at_valid_time: Freeze valid time coordinate (ISO 8601 UTC)
        as_of_system_time: Freeze system time coordinate (ISO 8601 UTC)

    Returns:
        SimulationResult with base_result, shadow_result, and metadata

    Raises:
        SchemaInvalidError: If RFA schema invalid
        InputInvalidError: If field format invalid or simulation_spec malformed

    Example:
        >>> result = engine.simulate_rfa(
        ...     rfa_dict={"namespace": "corp.hr", "requester_namespace": "corp.hr",
        ...               "requester_id": "analyst:bob", "subject": "employee:alice"},
        ...     simulation_spec={"shadow_facts": [
        ...         {"base_cell_id": "abc123...", "object": "90000"}  # What if salary was 90000?
        ...     ]},
        ...     at_valid_time="2025-01-15T00:00:00Z",
        ...     as_of_system_time="2025-01-15T00:00:00Z"
        ... )
        >>> print(result.base_result)  # Original salary
        >>> print(result.shadow_result)  # Modified salary
    """
    try:
        # Step 1: Canonicalize RFA (reuse existing method)
        canonical_rfa = self._canonicalize_rfa(rfa_dict)

        # Step 2: Validate RFA schema and fields (reuse existing)
        self._validate_rfa_schema(canonical_rfa)
        self._validate_rfa_fields(canonical_rfa)

        # Step 3: Query base reality at frozen coordinates (SIM-02, SHD-05)
        base_query_result = self.scholar.query_facts(
            requester_namespace=canonical_rfa['requester_namespace'],
            namespace=canonical_rfa['namespace'],
            subject=canonical_rfa.get('subject'),
            predicate=canonical_rfa.get('predicate'),
            object_value=canonical_rfa.get('object'),
            at_valid_time=at_valid_time,
            as_of_system_time=as_of_system_time,
            requester_id=canonical_rfa['requester_id']
        )
        base_result = base_query_result.to_proof_bundle()

        # Step 4: Build OverlayContext from simulation_spec
        overlay_ctx = self._build_overlay_context(simulation_spec)

        # Step 5: Run shadow query in context manager (SIM-03, cleanup guaranteed)
        # NOTE: SimulationContext.__enter__ appends shadow cells from overlay_ctx
        # to shadow_chain BEFORE creating shadow_scholar, so Scholar sees them.
        with SimulationContext(
            self.chain, overlay_ctx, at_valid_time, as_of_system_time
        ) as sim_ctx:
            # Query shadow reality (same RFA, same frozen coordinates)
            shadow_query_result = sim_ctx.shadow_scholar.query_facts(
                requester_namespace=canonical_rfa['requester_namespace'],
                namespace=canonical_rfa['namespace'],
                subject=canonical_rfa.get('subject'),
                predicate=canonical_rfa.get('predicate'),
                object_value=canonical_rfa.get('object'),
                at_valid_time=at_valid_time,
                as_of_system_time=as_of_system_time,
                requester_id=canonical_rfa['requester_id']
            )
            shadow_result = shadow_query_result.to_proof_bundle()
        # Context manager __exit__ called here - shadow_chain discarded

        # Step 6: Create immutable SimulationResult
        from uuid import uuid4
        return SimulationResult(
            simulation_id=str(uuid4()),
            rfa_dict=canonical_rfa,
            simulation_spec=simulation_spec,
            base_result=base_result,
            shadow_result=shadow_result,
            at_valid_time=at_valid_time,
            as_of_system_time=as_of_system_time
        )

    except DecisionGraphError:
        raise
    except (ValueError, TypeError, KeyError) as e:
        raise wrap_internal_exception(
            e, details={"operation": "simulate_rfa"}
        ) from e
    except Exception as e:
        raise wrap_internal_exception(
            e, details={"operation": "simulate_rfa"}
        ) from e

def _build_overlay_context(self, simulation_spec: dict) -> OverlayContext:
    """
    Build OverlayContext from simulation_spec.

    Processes shadow_facts, shadow_rules, shadow_policy_heads, shadow_bridges
    from simulation_spec and creates shadow cells using Phase 7 functions.

    Args:
        simulation_spec: Dict with shadow cell specifications

    Returns:
        OverlayContext populated with shadow cells
    """
    ctx = OverlayContext()

    # Process shadow facts
    for spec in simulation_spec.get('shadow_facts', []):
        base_cell_id = spec.get('base_cell_id')
        if base_cell_id:
            base_cell = self.chain.get_cell(base_cell_id)
            if base_cell:
                shadow_cell = create_shadow_fact(
                    base_cell,
                    object=spec.get('object'),
                    confidence=spec.get('confidence'),
                    valid_from=spec.get('valid_from'),
                    valid_to=spec.get('valid_to')
                )
                ctx.add_shadow_fact(shadow_cell, base_cell_id)

    # Process shadow rules
    for spec in simulation_spec.get('shadow_rules', []):
        base_cell_id = spec.get('base_cell_id')
        if base_cell_id:
            base_cell = self.chain.get_cell(base_cell_id)
            if base_cell:
                shadow_cell = create_shadow_rule(
                    base_cell,
                    rule_logic_hash=spec.get('rule_logic_hash')
                )
                ctx.add_shadow_rule(shadow_cell, base_cell_id)

    # Process shadow policy heads
    for spec in simulation_spec.get('shadow_policy_heads', []):
        base_cell_id = spec.get('base_cell_id')
        if base_cell_id:
            base_cell = self.chain.get_cell(base_cell_id)
            if base_cell:
                shadow_cell = create_shadow_policy_head(
                    base_cell,
                    promoted_rule_ids=spec.get('promoted_rule_ids')
                )
                ctx.add_shadow_policy_head(shadow_cell, base_cell_id)

    # Process shadow bridges
    for spec in simulation_spec.get('shadow_bridges', []):
        base_cell_id = spec.get('base_cell_id')
        if base_cell_id:
            base_cell = self.chain.get_cell(base_cell_id)
            if base_cell:
                shadow_cell = create_shadow_bridge(
                    base_cell,
                    object=spec.get('object')  # target namespace
                )
                ctx.add_shadow_bridge(shadow_cell, base_cell_id)

    return ctx
```

Update `__all__` in engine.py to include any new exports if needed.
  </action>
  <verify>
```bash
# Verify method exists and is callable
python3 -c "
from decisiongraph import Engine, create_chain
chain = create_chain('test', 'test_ns')
engine = Engine(chain)
assert hasattr(engine, 'simulate_rfa'), 'simulate_rfa method missing'
assert callable(engine.simulate_rfa), 'simulate_rfa not callable'
print('OK: Engine.simulate_rfa exists')
"
```
  </verify>
  <done>Engine.simulate_rfa() method exists with full implementation. Method accepts RFA, simulation_spec, and bitemporal coordinates. Returns SimulationResult with base and shadow results.</done>
</task>

<task type="auto">
  <name>Task 2: Simulation integration tests</name>
  <files>tests/test_simulation.py</files>
  <action>
Create comprehensive test file `tests/test_simulation.py` covering all Phase 8 requirements.

```python
"""
Tests for Phase 8: Simulation Core

Tests cover:
- SIM-01: engine.simulate_rfa() entry point
- SIM-02: Base reality frozen at specified coordinates
- SIM-03: Shadow overlay deterministic precedence
- SHD-05: Bitemporal simulation respects frozen coordinates

All tests verify zero contamination (base chain unchanged after simulation).
"""

import pytest
from uuid import uuid4

from decisiongraph import (
    Engine,
    create_chain,
    create_fact_cell,
    create_rule_cell,
    SimulationContext,
    SimulationResult
)
from decisiongraph.shadow import (
    OverlayContext,
    create_shadow_fact,
    fork_shadow_chain
)
from decisiongraph.cell import get_current_timestamp


# =============================================================================
# FIXTURES
# =============================================================================

@pytest.fixture
def basic_chain():
    """Create chain with basic facts for simulation testing."""
    chain = create_chain("sim_test_graph", "corp")

    # Create a rule first (facts need to reference a rule)
    rule = create_rule_cell(
        namespace="corp",
        subject="rule:salary_v1",
        predicate="defines",
        object_value="salary_calculation",
        rule_id="rule:salary_v1",
        rule_logic_hash="hash_salary_v1",
        graph_id="sim_test_graph",
        prev_cell_hash=chain.head.cell_id
    )
    chain.append(rule)

    # Create test facts
    fact1 = create_fact_cell(
        namespace="corp",
        subject="employee:alice",
        predicate="has_salary",
        object_value="80000",
        rule_id="rule:salary_v1",
        graph_id="sim_test_graph",
        prev_cell_hash=chain.head.cell_id,
        system_time="2025-01-01T00:00:00Z",
        valid_from="2025-01-01T00:00:00Z"
    )
    chain.append(fact1)

    fact2 = create_fact_cell(
        namespace="corp",
        subject="employee:bob",
        predicate="has_salary",
        object_value="75000",
        rule_id="rule:salary_v1",
        graph_id="sim_test_graph",
        prev_cell_hash=chain.head.cell_id,
        system_time="2025-01-01T00:00:00Z",
        valid_from="2025-01-01T00:00:00Z"
    )
    chain.append(fact2)

    return chain


@pytest.fixture
def engine_with_facts(basic_chain):
    """Create engine with basic facts."""
    return Engine(basic_chain), basic_chain


# =============================================================================
# SIM-01: engine.simulate_rfa() entry point
# =============================================================================

class TestSimulateRfaEntryPoint:
    """Tests for SIM-01: engine.simulate_rfa() accepts RFA + simulation_spec + coordinates"""

    def test_simulate_rfa_returns_simulation_result(self, engine_with_facts):
        """simulate_rfa returns SimulationResult with correct type."""
        engine, chain = engine_with_facts

        result = engine.simulate_rfa(
            rfa_dict={
                "namespace": "corp",
                "requester_namespace": "corp",
                "requester_id": "analyst:test",
                "subject": "employee:alice",
                "predicate": "has_salary"
            },
            simulation_spec={},  # Empty spec = no shadow changes
            at_valid_time="2025-01-15T00:00:00Z",
            as_of_system_time="2025-01-15T00:00:00Z"
        )

        assert isinstance(result, SimulationResult)
        assert result.simulation_id is not None
        assert result.at_valid_time == "2025-01-15T00:00:00Z"
        assert result.as_of_system_time == "2025-01-15T00:00:00Z"

    def test_simulate_rfa_with_empty_spec_returns_identical_results(self, engine_with_facts):
        """With empty simulation_spec, base and shadow results should be identical."""
        engine, chain = engine_with_facts

        result = engine.simulate_rfa(
            rfa_dict={
                "namespace": "corp",
                "requester_namespace": "corp",
                "requester_id": "analyst:test"
            },
            simulation_spec={},
            at_valid_time="2025-01-15T00:00:00Z",
            as_of_system_time="2025-01-15T00:00:00Z"
        )

        # With no shadow cells, base and shadow should return same facts
        assert result.base_result["results"]["fact_count"] == result.shadow_result["results"]["fact_count"]

    def test_simulate_rfa_validates_rfa_schema(self, engine_with_facts):
        """simulate_rfa validates RFA schema (missing required fields)."""
        engine, chain = engine_with_facts
        from decisiongraph.exceptions import SchemaInvalidError

        with pytest.raises(SchemaInvalidError):
            engine.simulate_rfa(
                rfa_dict={"namespace": "corp"},  # Missing requester_namespace, requester_id
                simulation_spec={},
                at_valid_time="2025-01-15T00:00:00Z",
                as_of_system_time="2025-01-15T00:00:00Z"
            )


# =============================================================================
# SIM-02: Base reality frozen at specified coordinates
# =============================================================================

class TestBaseRealityFrozen:
    """Tests for SIM-02: Base reality frozen at specified coordinates"""

    def test_base_result_uses_specified_valid_time(self, engine_with_facts):
        """Base query uses specified at_valid_time."""
        engine, chain = engine_with_facts

        # Query at time BEFORE facts exist
        result = engine.simulate_rfa(
            rfa_dict={
                "namespace": "corp",
                "requester_namespace": "corp",
                "requester_id": "analyst:test",
                "subject": "employee:alice"
            },
            simulation_spec={},
            at_valid_time="2024-01-01T00:00:00Z",  # Before facts valid_from
            as_of_system_time="2025-01-15T00:00:00Z"
        )

        # Facts not valid at that time
        assert result.base_result["results"]["fact_count"] == 0

    def test_base_result_uses_specified_system_time(self, engine_with_facts):
        """Base query uses specified as_of_system_time."""
        engine, chain = engine_with_facts

        # Query at system time BEFORE facts recorded
        result = engine.simulate_rfa(
            rfa_dict={
                "namespace": "corp",
                "requester_namespace": "corp",
                "requester_id": "analyst:test"
            },
            simulation_spec={},
            at_valid_time="2025-01-15T00:00:00Z",
            as_of_system_time="2024-01-01T00:00:00Z"  # Before facts system_time
        )

        # Facts not known at that system time
        assert result.base_result["results"]["fact_count"] == 0


# =============================================================================
# SIM-03: Shadow overlay deterministic precedence
# =============================================================================

class TestShadowOverlayPrecedence:
    """Tests for SIM-03: Shadow overlay injection follows deterministic precedence"""

    def test_shadow_fact_overrides_base_fact(self, engine_with_facts):
        """Shadow fact for same key overrides base fact in shadow result."""
        engine, chain = engine_with_facts

        # Find Alice's salary cell
        alice_salary_cell = None
        for cell in chain.cells:
            if (hasattr(cell.fact, 'subject') and
                cell.fact.subject == "employee:alice" and
                cell.fact.predicate == "has_salary"):
                alice_salary_cell = cell
                break

        assert alice_salary_cell is not None, "Alice salary fact not found"

        # Simulate with shadow salary of 90000
        result = engine.simulate_rfa(
            rfa_dict={
                "namespace": "corp",
                "requester_namespace": "corp",
                "requester_id": "analyst:test",
                "subject": "employee:alice",
                "predicate": "has_salary"
            },
            simulation_spec={
                "shadow_facts": [{
                    "base_cell_id": alice_salary_cell.cell_id,
                    "object": "90000"
                }]
            },
            at_valid_time="2025-01-15T00:00:00Z",
            as_of_system_time="2025-01-15T00:00:00Z"
        )

        # Base should have original value (80000)
        assert result.base_result["results"]["fact_count"] == 1

        # Shadow should have the shadow cell included
        # NOTE: The shadow_scholar queries shadow_chain which now includes shadow cells
        # appended by SimulationContext.__enter__. The shadow cell with object="90000"
        # should be visible. The exact result depends on how Scholar handles is_shadow
        # cells vs base cells. At minimum, shadow_result should contain 1+ facts.
        assert result.shadow_result["results"]["fact_count"] >= 1

    def test_shadow_cells_visible_in_shadow_chain(self, engine_with_facts):
        """Verify shadow cells are appended to shadow_chain and visible to Scholar."""
        engine, chain = engine_with_facts

        # Find a fact cell
        fact_cell = None
        for cell in chain.cells:
            if hasattr(cell.fact, 'subject') and cell.fact.predicate == "has_salary":
                fact_cell = cell
                break

        assert fact_cell is not None

        # Create OverlayContext manually to inspect
        overlay_ctx = OverlayContext()
        shadow_cell = create_shadow_fact(fact_cell, object="99999")
        overlay_ctx.add_shadow_fact(shadow_cell, fact_cell.cell_id)

        # Use SimulationContext directly to verify shadow cells appended
        from decisiongraph.simulation import SimulationContext

        sim = SimulationContext(
            chain, overlay_ctx,
            "2025-01-15T00:00:00Z",
            "2025-01-15T00:00:00Z"
        )

        with sim as s:
            # Check shadow_chain contains our shadow cell
            shadow_cells_in_chain = [
                c for c in s.shadow_chain.cells
                if getattr(c.fact, 'is_shadow', False)
            ]
            assert len(shadow_cells_in_chain) >= 1, "Shadow cell not found in shadow_chain"


# =============================================================================
# SHD-05: Bitemporal simulation respects frozen coordinates
# =============================================================================

class TestBitemporalSimulation:
    """Tests for SHD-05: Bitemporal simulation respects frozen coordinates"""

    def test_simulation_coordinates_passed_to_result(self, engine_with_facts):
        """SimulationResult contains correct bitemporal coordinates."""
        engine, chain = engine_with_facts

        result = engine.simulate_rfa(
            rfa_dict={
                "namespace": "corp",
                "requester_namespace": "corp",
                "requester_id": "analyst:test"
            },
            simulation_spec={},
            at_valid_time="2025-06-15T12:30:00Z",
            as_of_system_time="2025-06-15T12:30:00Z"
        )

        assert result.at_valid_time == "2025-06-15T12:30:00Z"
        assert result.as_of_system_time == "2025-06-15T12:30:00Z"

    def test_both_queries_use_same_coordinates(self, engine_with_facts):
        """Base and shadow queries use same frozen coordinates."""
        engine, chain = engine_with_facts

        result = engine.simulate_rfa(
            rfa_dict={
                "namespace": "corp",
                "requester_namespace": "corp",
                "requester_id": "analyst:test"
            },
            simulation_spec={},
            at_valid_time="2025-01-15T00:00:00Z",
            as_of_system_time="2025-01-15T00:00:00Z"
        )

        # Both proof bundles should have same time_filters
        base_time = result.base_result["time_filters"]
        shadow_time = result.shadow_result["time_filters"]

        assert base_time["at_valid_time"] == shadow_time["at_valid_time"]
        assert base_time["as_of_system_time"] == shadow_time["as_of_system_time"]


# =============================================================================
# ZERO CONTAMINATION
# =============================================================================

class TestZeroContamination:
    """Tests verifying base chain is never modified by simulation"""

    def test_base_chain_length_unchanged(self, engine_with_facts):
        """Base chain length unchanged after simulation."""
        engine, chain = engine_with_facts
        original_length = len(chain.cells)

        # Run simulation
        engine.simulate_rfa(
            rfa_dict={
                "namespace": "corp",
                "requester_namespace": "corp",
                "requester_id": "analyst:test"
            },
            simulation_spec={
                "shadow_facts": [{
                    "base_cell_id": chain.cells[2].cell_id,  # Some fact
                    "object": "99999"
                }]
            },
            at_valid_time="2025-01-15T00:00:00Z",
            as_of_system_time="2025-01-15T00:00:00Z"
        )

        assert len(chain.cells) == original_length

    def test_base_chain_head_unchanged(self, engine_with_facts):
        """Base chain head unchanged after simulation."""
        engine, chain = engine_with_facts
        original_head_id = chain.head.cell_id

        engine.simulate_rfa(
            rfa_dict={
                "namespace": "corp",
                "requester_namespace": "corp",
                "requester_id": "analyst:test"
            },
            simulation_spec={},
            at_valid_time="2025-01-15T00:00:00Z",
            as_of_system_time="2025-01-15T00:00:00Z"
        )

        assert chain.head.cell_id == original_head_id


# =============================================================================
# SIMULATION CONTEXT
# =============================================================================

class TestSimulationContext:
    """Tests for SimulationContext context manager"""

    def test_context_manager_creates_shadow_chain(self, basic_chain):
        """SimulationContext creates shadow chain on enter."""
        ctx = OverlayContext()
        sim = SimulationContext(
            basic_chain, ctx,
            "2025-01-15T00:00:00Z",
            "2025-01-15T00:00:00Z"
        )

        assert sim.shadow_chain is None

        with sim as s:
            assert s.shadow_chain is not None
            assert s.shadow_scholar is not None

    def test_context_manager_cleans_up_on_exit(self, basic_chain):
        """SimulationContext cleans up shadow chain on exit."""
        ctx = OverlayContext()
        sim = SimulationContext(
            basic_chain, ctx,
            "2025-01-15T00:00:00Z",
            "2025-01-15T00:00:00Z"
        )

        with sim:
            pass

        assert sim.shadow_chain is None
        assert sim.shadow_scholar is None

    def test_context_manager_cleans_up_on_exception(self, basic_chain):
        """SimulationContext cleans up even when exception occurs."""
        ctx = OverlayContext()
        sim = SimulationContext(
            basic_chain, ctx,
            "2025-01-15T00:00:00Z",
            "2025-01-15T00:00:00Z"
        )

        with pytest.raises(ValueError):
            with sim:
                raise ValueError("Test exception")

        # Cleanup should still happen
        assert sim.shadow_chain is None
        assert sim.shadow_scholar is None

    def test_context_manager_appends_shadow_cells(self, basic_chain):
        """SimulationContext appends shadow cells from OverlayContext to shadow_chain."""
        # Find a fact cell to shadow
        fact_cell = None
        for cell in basic_chain.cells:
            if hasattr(cell.fact, 'subject') and cell.fact.predicate == "has_salary":
                fact_cell = cell
                break

        assert fact_cell is not None, "No fact cell found"

        # Create overlay with shadow cell
        ctx = OverlayContext()
        shadow_cell = create_shadow_fact(fact_cell, object="modified_value")
        ctx.add_shadow_fact(shadow_cell, fact_cell.cell_id)

        sim = SimulationContext(
            basic_chain, ctx,
            "2025-01-15T00:00:00Z",
            "2025-01-15T00:00:00Z"
        )

        with sim as s:
            # Verify shadow cell is in shadow_chain
            shadow_cells = [
                c for c in s.shadow_chain.cells
                if getattr(c.fact, 'is_shadow', False)
            ]
            assert len(shadow_cells) >= 1, "Shadow cell not appended to shadow_chain"


# =============================================================================
# SIMULATION RESULT
# =============================================================================

class TestSimulationResult:
    """Tests for SimulationResult frozen dataclass"""

    def test_result_is_frozen(self):
        """SimulationResult cannot be modified after creation."""
        result = SimulationResult(
            simulation_id="test-id",
            rfa_dict={"namespace": "corp"},
            simulation_spec={},
            base_result={},
            shadow_result={},
            at_valid_time="2025-01-01T00:00:00Z",
            as_of_system_time="2025-01-01T00:00:00Z"
        )

        with pytest.raises(Exception):  # FrozenInstanceError
            result.simulation_id = "modified"

    def test_result_to_dict(self):
        """SimulationResult.to_dict() returns serializable dict."""
        result = SimulationResult(
            simulation_id="test-id",
            rfa_dict={"namespace": "corp"},
            simulation_spec={"shadow_facts": []},
            base_result={"results": {"fact_count": 1}},
            shadow_result={"results": {"fact_count": 1}},
            at_valid_time="2025-01-01T00:00:00Z",
            as_of_system_time="2025-01-01T00:00:00Z"
        )

        d = result.to_dict()

        assert d["simulation_id"] == "test-id"
        assert d["rfa_dict"] == {"namespace": "corp"}
        assert d["at_valid_time"] == "2025-01-01T00:00:00Z"


# =============================================================================
# EDGE CASES
# =============================================================================

class TestSimulationEdgeCases:
    """Edge case tests for simulation"""

    def test_simulate_with_nonexistent_base_cell(self, engine_with_facts):
        """Simulation gracefully handles nonexistent base_cell_id."""
        engine, chain = engine_with_facts

        # Should not raise - just ignores invalid base_cell_id
        result = engine.simulate_rfa(
            rfa_dict={
                "namespace": "corp",
                "requester_namespace": "corp",
                "requester_id": "analyst:test"
            },
            simulation_spec={
                "shadow_facts": [{
                    "base_cell_id": "nonexistent_cell_id",
                    "object": "99999"
                }]
            },
            at_valid_time="2025-01-15T00:00:00Z",
            as_of_system_time="2025-01-15T00:00:00Z"
        )

        assert isinstance(result, SimulationResult)

    def test_simulate_with_empty_simulation_spec_keys(self, engine_with_facts):
        """Simulation handles simulation_spec with empty lists."""
        engine, chain = engine_with_facts

        result = engine.simulate_rfa(
            rfa_dict={
                "namespace": "corp",
                "requester_namespace": "corp",
                "requester_id": "analyst:test"
            },
            simulation_spec={
                "shadow_facts": [],
                "shadow_rules": [],
                "shadow_policy_heads": [],
                "shadow_bridges": []
            },
            at_valid_time="2025-01-15T00:00:00Z",
            as_of_system_time="2025-01-15T00:00:00Z"
        )

        assert isinstance(result, SimulationResult)
```
  </action>
  <verify>
```bash
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_simulation.py -v
```
  </verify>
  <done>Comprehensive test file created covering SIM-01, SIM-02, SIM-03, SHD-05. All tests pass. Zero contamination verified.</done>
</task>

</tasks>

<verification>
All checks must pass:

1. Engine.simulate_rfa() exists and is callable:
   ```bash
   python3 -c "
   from decisiongraph import Engine, create_chain
   engine = Engine(create_chain('g', 'ns'))
   assert callable(engine.simulate_rfa)
   print('OK: simulate_rfa exists')
   "
   ```

2. Simulation tests pass:
   ```bash
   cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_simulation.py -v
   ```

3. All existing tests still pass:
   ```bash
   cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/ -q --tb=no
   ```

4. Zero contamination verified (base chain unchanged):
   ```bash
   python3 -c "
   from decisiongraph import Engine, create_chain, create_fact_cell, create_rule_cell

   chain = create_chain('g', 'ns')
   rule = create_rule_cell('ns', 'rule:r1', 'defines', 'test', 'rule:r1', 'hash', 'g', chain.head.cell_id)
   chain.append(rule)
   fact = create_fact_cell('ns', 'subj', 'pred', 'val', 'rule:r1', 'g', chain.head.cell_id)
   chain.append(fact)

   original_length = len(chain.cells)
   original_head = chain.head.cell_id

   engine = Engine(chain)
   result = engine.simulate_rfa(
       {'namespace': 'ns', 'requester_namespace': 'ns', 'requester_id': 'test'},
       {'shadow_facts': [{'base_cell_id': fact.cell_id, 'object': 'new_val'}]},
       '2025-01-01T00:00:00Z',
       '2025-01-01T00:00:00Z'
   )

   assert len(chain.cells) == original_length, 'Chain length changed!'
   assert chain.head.cell_id == original_head, 'Chain head changed!'
   print('OK: Zero contamination verified')
   "
   ```
</verification>

<success_criteria>
- [ ] `Engine.simulate_rfa()` method implemented with full functionality
- [ ] Method accepts RFA dict, simulation_spec, at_valid_time, as_of_system_time
- [ ] Method returns SimulationResult with base_result and shadow_result
- [ ] `_build_overlay_context()` helper method creates OverlayContext from spec
- [ ] `tests/test_simulation.py` created with comprehensive tests
- [ ] Tests cover SIM-01, SIM-02, SIM-03, SHD-05 requirements
- [ ] Zero contamination verified (base chain unchanged after simulation)
- [ ] Context manager cleanup verified (shadow resources released on exit)
- [ ] Shadow cells appended to shadow_chain verified
- [ ] All simulation tests pass
- [ ] All 795+ existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/08-simulation-core/08-02-SUMMARY.md`
</output>
