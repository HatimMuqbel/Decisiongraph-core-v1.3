---
phase: 04-promotion-workflow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/decisiongraph/promotion.py
  - src/decisiongraph/__init__.py
  - tests/test_promotion.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "PromotionRequest can be created with namespace, rule_ids, submitter_id, threshold"
    - "PromotionStatus enum has PENDING, COLLECTING, THRESHOLD_MET, FINALIZED, REJECTED states"
    - "PromotionRequest.rule_ids is immutable (tuple, not list)"
    - "PromotionRequest.canonical_payload is deterministic (sorted rule_ids, includes promotion_id)"
  artifacts:
    - path: "src/decisiongraph/promotion.py"
      provides: "PromotionRequest dataclass, PromotionStatus enum, canonical payload creation"
      exports: ["PromotionRequest", "PromotionStatus"]
    - path: "tests/test_promotion.py"
      provides: "Unit tests for PromotionRequest and PromotionStatus"
      min_tests: 8
  key_links:
    - from: "src/decisiongraph/promotion.py"
      to: "json.dumps with sort_keys=True"
      via: "canonical_payload creation"
      pattern: "json\\.dumps.*sort_keys.*True"
    - from: "src/decisiongraph/__init__.py"
      to: "src/decisiongraph/promotion.py"
      via: "export PromotionRequest, PromotionStatus"
      pattern: "from \\.promotion import"
---

<objective>
Create the PromotionRequest data model and PromotionStatus state machine enum for tracking promotion lifecycle.

Purpose: PromotionRequest is the core data structure that tracks a promotion from submission through signature collection to finalization. It must be immutable where required (rule_ids) and provide deterministic canonical_payload for witness signatures (PRO-03).

Output: promotion.py module with PromotionRequest dataclass, PromotionStatus enum, unit tests validating state transitions and canonical payload determinism.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-promotion-workflow/04-RESEARCH.md

# Existing patterns to follow
@src/decisiongraph/witnessset.py (frozen dataclass pattern)
@src/decisiongraph/exceptions.py (error types)
@src/decisiongraph/cell.py (get_current_timestamp)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create promotion.py with PromotionStatus enum and PromotionRequest dataclass</name>
  <files>src/decisiongraph/promotion.py</files>
  <action>
Create new module src/decisiongraph/promotion.py with:

1. **PromotionStatus enum** (str, Enum):
   - PENDING = "pending" (created, no signatures yet)
   - COLLECTING = "collecting" (has at least one signature)
   - THRESHOLD_MET = "threshold_met" (threshold reached, ready to finalize)
   - FINALIZED = "finalized" (PolicyHead created)
   - REJECTED = "rejected" (explicitly rejected or expired)

2. **PromotionRequest dataclass** (NOT frozen - has mutable state):
   Immutable fields set at creation:
   - promotion_id: str (UUID)
   - namespace: str
   - rule_ids: tuple[str, ...] (immutable - use tuple NOT list)
   - submitter_id: str
   - created_at: str (ISO 8601)
   - canonical_payload: bytes (what witnesses sign)
   - required_threshold: int

   Mutable state during collection:
   - status: PromotionStatus = PENDING
   - signatures: Dict[str, bytes] = field(default_factory=dict)

3. **PromotionRequest.create() class method**:
   Factory that ensures canonical payload creation:
   - Generates promotion_id via uuid.uuid4()
   - Sorts rule_ids and stores as tuple (immutability)
   - Creates canonical_payload as JSON bytes:
     ```python
     payload_dict = {
         "promotion_id": promotion_id,
         "namespace": namespace,
         "rule_ids": list(sorted_rule_ids),
         "timestamp": created_at
     }
     canonical_payload = json.dumps(
         payload_dict, sort_keys=True, separators=(',', ':')
     ).encode('utf-8')
     ```

Use get_current_timestamp from cell.py for created_at default.
Use Dict from typing, not dict (Python 3.10 compatibility).

IMPORTANT: Do NOT make PromotionRequest frozen=True. It has mutable state (status, signatures).
IMPORTANT: Use tuple[str, ...] for rule_ids to ensure immutability (list can be mutated even in dataclass).
  </action>
  <verify>
python -c "from decisiongraph.promotion import PromotionRequest, PromotionStatus; print(PromotionStatus.PENDING.value)"
  </verify>
  <done>
PromotionStatus enum has 5 states, PromotionRequest.create() generates promotion_id and canonical_payload.
  </done>
</task>

<task type="auto">
  <name>Task 2: Export from __init__.py and create comprehensive tests</name>
  <files>src/decisiongraph/__init__.py, tests/test_promotion.py</files>
  <action>
1. **Update src/decisiongraph/__init__.py**:
   Add import and export:
   ```python
   from .promotion import PromotionRequest, PromotionStatus
   ```
   Add to __all__ list.

2. **Create tests/test_promotion.py** with tests for:
   - test_promotion_status_values: All 5 states have correct string values
   - test_promotion_request_create: Factory creates valid request with UUID promotion_id
   - test_promotion_request_rule_ids_immutable: rule_ids is tuple (cannot mutate)
   - test_promotion_request_canonical_payload_deterministic: Same inputs = same canonical_payload
   - test_promotion_request_canonical_payload_sorted: Different rule_id order = same payload
   - test_promotion_request_initial_status_pending: Status is PENDING after create
   - test_promotion_request_signatures_empty: signatures dict is empty after create
   - test_promotion_request_status_mutable: Can change status from PENDING to COLLECTING

Test pattern:
```python
from decisiongraph import PromotionRequest, PromotionStatus

def test_promotion_request_canonical_payload_deterministic():
    """Same inputs produce same canonical_payload (determinism)."""
    pr1 = PromotionRequest.create(
        namespace="corp",
        rule_ids=["rule:a", "rule:b"],
        submitter_id="alice",
        threshold=2,
        created_at="2026-01-15T10:00:00Z"
    )
    pr2 = PromotionRequest.create(
        namespace="corp",
        rule_ids=["rule:a", "rule:b"],
        submitter_id="alice",
        threshold=2,
        created_at="2026-01-15T10:00:00Z"
    )
    # Same inputs except promotion_id (UUID) - extract payload without promotion_id
    # Actually, since promotion_id differs, canonical_payload will differ
    # The determinism is: same promotion_id + same inputs = same payload
    # Test that sorted rule_ids are in the payload
    assert b'"rule_ids":["rule:a","rule:b"]' in pr1.canonical_payload
```

Use T0 = "2026-01-15T10:00:00Z" as fixed timestamp for deterministic tests.
  </action>
  <verify>
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_promotion.py -v
  </verify>
  <done>
All 8+ tests pass, PromotionRequest and PromotionStatus exported from decisiongraph package.
  </done>
</task>

</tasks>

<verification>
```bash
# Run all promotion tests
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_promotion.py -v

# Verify exports work
python -c "from decisiongraph import PromotionRequest, PromotionStatus; pr = PromotionRequest.create('corp', ['r1'], 'alice', 1, '2026-01-15T10:00:00Z'); print(pr.status, pr.rule_ids)"

# Run all tests (682 existing must still pass)
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest --tb=short
```
</verification>

<success_criteria>
1. PromotionStatus enum has PENDING, COLLECTING, THRESHOLD_MET, FINALIZED, REJECTED values
2. PromotionRequest.create() generates UUID promotion_id and deterministic canonical_payload
3. PromotionRequest.rule_ids is tuple (immutable)
4. All new tests pass (8+)
5. All 682 existing tests still pass
6. PromotionRequest and PromotionStatus exported from decisiongraph package
</success_criteria>

<output>
After completion, create `.planning/phases/04-promotion-workflow/04-01-SUMMARY.md`
</output>
