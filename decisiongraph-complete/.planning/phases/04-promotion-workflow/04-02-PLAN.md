---
phase: 04-promotion-workflow
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/decisiongraph/engine.py
  - tests/test_engine_promotion.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can call engine.submit_promotion(namespace, rule_ids, submitter_id) and receive promotion_id"
    - "User can call engine.collect_witness_signature(promotion_id, witness_id, signature) and status updates"
    - "Unauthorized witness raises DG_UNAUTHORIZED error"
    - "Invalid signature raises DG_SIGNATURE_INVALID error"
    - "Status transitions: PENDING -> COLLECTING (first sig) -> THRESHOLD_MET (threshold reached)"
  artifacts:
    - path: "src/decisiongraph/engine.py"
      provides: "submit_promotion(), collect_witness_signature() methods on Engine class"
      contains: "def submit_promotion"
    - path: "tests/test_engine_promotion.py"
      provides: "Integration tests for promotion submission and signature collection"
      min_tests: 10
  key_links:
    - from: "src/decisiongraph/engine.py"
      to: "src/decisiongraph/registry.py"
      via: "WitnessRegistry.get_witness_set()"
      pattern: "get_witness_set"
    - from: "src/decisiongraph/engine.py"
      to: "src/decisiongraph/signing.py"
      via: "verify_signature()"
      pattern: "verify_signature"
    - from: "src/decisiongraph/engine.py"
      to: "src/decisiongraph/promotion.py"
      via: "PromotionRequest.create()"
      pattern: "PromotionRequest\\.create"
---

<objective>
Extend Engine class with submit_promotion() and collect_witness_signature() methods (PRO-01, PRO-02, PRO-05, PRO-06).

Purpose: Engine becomes the API for promotion workflow. submit_promotion() creates PromotionRequest and returns promotion_id. collect_witness_signature() validates witness authorization, verifies Ed25519 signature, stores signature, and updates status.

Output: Engine class with promotion methods, comprehensive tests covering happy path and error cases (unauthorized witness, invalid signature).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-promotion-workflow/04-RESEARCH.md
@.planning/phases/04-promotion-workflow/04-01-SUMMARY.md

# Implementation references
@src/decisiongraph/engine.py (existing Engine class to extend)
@src/decisiongraph/registry.py (WitnessRegistry.get_witness_set)
@src/decisiongraph/signing.py (verify_signature - returns False not exception)
@src/decisiongraph/promotion.py (from Plan 01)
@src/decisiongraph/exceptions.py (UnauthorizedError, SignatureInvalidError)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Engine with submit_promotion() and _promotions storage</name>
  <files>src/decisiongraph/engine.py</files>
  <action>
Modify src/decisiongraph/engine.py:

1. **Add imports at top**:
   ```python
   from .promotion import PromotionRequest, PromotionStatus
   from .registry import WitnessRegistry
   ```

2. **Extend Engine.__init__()**:
   Add after existing initialization:
   ```python
   # Promotion workflow state (v1.5)
   self._promotions: Dict[str, PromotionRequest] = {}
   self._registry = WitnessRegistry(chain)
   ```

3. **Add Engine.submit_promotion() method**:
   ```python
   def submit_promotion(
       self,
       namespace: str,
       rule_ids: List[str],
       submitter_id: str
   ) -> str:
       """
       Submit a promotion request (PRO-01).

       Creates a PromotionRequest tracking the promotion of rule_ids
       for the given namespace. Returns promotion_id for subsequent
       signature collection.

       Args:
           namespace: Target namespace for promotion
           rule_ids: List of rule IDs to promote
           submitter_id: Identifier of who is submitting

       Returns:
           promotion_id: Unique identifier for this promotion

       Raises:
           InputInvalidError: If namespace invalid or no WitnessSet configured

       Example:
           >>> promotion_id = engine.submit_promotion(
           ...     namespace="corp",
           ...     rule_ids=["rule:salary_v2", "rule:benefits_v1"],
           ...     submitter_id="alice"
           ... )
       """
       # Validate namespace format
       if not validate_namespace(namespace):
           raise InputInvalidError(
               message=f"Invalid namespace: '{namespace}'",
               details={"namespace": namespace}
           )

       # Get WitnessSet for threshold
       witness_set = self._registry.get_witness_set(namespace)
       if not witness_set:
           raise InputInvalidError(
               message=f"No WitnessSet configured for namespace: {namespace}",
               details={"namespace": namespace}
           )

       # Create promotion request
       promotion = PromotionRequest.create(
           namespace=namespace,
           rule_ids=rule_ids,
           submitter_id=submitter_id,
           threshold=witness_set.threshold,
           created_at=get_current_timestamp()
       )

       # Store in active promotions
       self._promotions[promotion.promotion_id] = promotion

       return promotion.promotion_id
   ```

4. **Update __all__ export** to include nothing new (methods are on Engine class).

CRITICAL: Import Dict and List from typing at the top of file.
IMPORTANT: validate_namespace is already imported from .cell.
  </action>
  <verify>
python -c "from decisiongraph import Engine, create_chain; e = Engine(create_chain()); print(hasattr(e, 'submit_promotion'))"
  </verify>
  <done>
Engine has submit_promotion() method that creates and stores PromotionRequest.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Engine.collect_witness_signature() with authorization and verification</name>
  <files>src/decisiongraph/engine.py</files>
  <action>
Add collect_witness_signature() method to Engine class:

```python
def collect_witness_signature(
    self,
    promotion_id: str,
    witness_id: str,
    signature: bytes,
    public_key: bytes
) -> PromotionStatus:
    """
    Collect a witness signature for a promotion (PRO-02, PRO-05, PRO-06).

    Validates witness is in WitnessSet (PRO-05), verifies signature (PRO-06),
    stores signature, and updates status based on signature count.

    IMPORTANT: Authorization check BEFORE signature verification.
    Order matters: unauthorized witness should not trigger signature verification.

    Args:
        promotion_id: ID of promotion to add signature to
        witness_id: ID of the witness providing signature
        signature: 64-byte Ed25519 signature of canonical_payload
        public_key: 32-byte Ed25519 public key for verification

    Returns:
        Current PromotionStatus after signature collection

    Raises:
        InputInvalidError: If promotion_id not found
        UnauthorizedError: If witness not in WitnessSet (DG_UNAUTHORIZED)
        SignatureInvalidError: If signature verification fails (DG_SIGNATURE_INVALID)

    Example:
        >>> status = engine.collect_witness_signature(
        ...     promotion_id=promotion_id,
        ...     witness_id="alice",
        ...     signature=sig_bytes,
        ...     public_key=alice_pub_key
        ... )
        >>> print(status)  # PromotionStatus.COLLECTING or THRESHOLD_MET
    """
    # Get promotion
    promotion = self._promotions.get(promotion_id)
    if not promotion:
        raise InputInvalidError(
            message=f"Promotion not found: {promotion_id}",
            details={"promotion_id": promotion_id}
        )

    # PRO-05: Check witness authorization FIRST (before signature verification)
    witness_set = self._registry.get_witness_set(promotion.namespace)
    if witness_set is None:
        raise InputInvalidError(
            message=f"No WitnessSet for namespace: {promotion.namespace}",
            details={"namespace": promotion.namespace}
        )

    if witness_id not in witness_set.witnesses:
        raise UnauthorizedError(
            message=f"Witness '{witness_id}' not in WitnessSet for namespace '{promotion.namespace}'",
            details={
                "witness_id": witness_id,
                "namespace": promotion.namespace,
                "allowed_witnesses": list(witness_set.witnesses)
            }
        )

    # PRO-06: Verify signature
    # CRITICAL: verify_signature returns False on invalid, does NOT raise exception
    is_valid = verify_signature(public_key, promotion.canonical_payload, signature)
    if not is_valid:
        raise SignatureInvalidError(
            message=f"Signature verification failed for witness '{witness_id}'",
            details={
                "witness_id": witness_id,
                "promotion_id": promotion_id
            }
        )

    # Store signature (dict prevents duplicates - same witness overwrites)
    promotion.signatures[witness_id] = signature

    # Update status based on signature count
    sig_count = len(promotion.signatures)
    if sig_count == 1 and promotion.status == PromotionStatus.PENDING:
        promotion.status = PromotionStatus.COLLECTING
    if sig_count >= promotion.required_threshold:
        promotion.status = PromotionStatus.THRESHOLD_MET

    return promotion.status
```

CRITICAL: verify_signature returns bool. Check `if not is_valid:` and raise SignatureInvalidError explicitly.
CRITICAL: Authorization check (witness in WitnessSet) MUST come BEFORE signature verification.
  </action>
  <verify>
python -c "from decisiongraph import Engine; print(Engine.collect_witness_signature.__doc__[:50])"
  </verify>
  <done>
Engine.collect_witness_signature() validates authorization, verifies signature, updates status.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive tests for submit and collect</name>
  <files>tests/test_engine_promotion.py</files>
  <action>
Create tests/test_engine_promotion.py with tests:

```python
"""
Tests for Engine promotion workflow (PRO-01, PRO-02, PRO-05, PRO-06).
"""
import pytest
from decisiongraph import (
    Engine, create_chain, PromotionStatus,
    InputInvalidError, UnauthorizedError, SignatureInvalidError
)
from decisiongraph.genesis import create_genesis_cell_with_witness_set
from decisiongraph.signing import generate_ed25519_keypair, sign_bytes

# Fixed timestamps for deterministic tests
T0 = "2026-01-15T10:00:00Z"


def create_test_chain_with_witnesses(witnesses, threshold):
    """Create a chain with Genesis containing WitnessSet."""
    chain = create_chain()
    genesis = create_genesis_cell_with_witness_set(
        graph_name="TestGraph",
        root_namespace="corp",
        witnesses=witnesses,
        threshold=threshold
    )
    chain.append(genesis)
    return chain


class TestSubmitPromotion:
    """Tests for Engine.submit_promotion() (PRO-01)"""

    def test_submit_promotion_returns_promotion_id(self):
        """submit_promotion returns a valid promotion_id string."""
        chain = create_test_chain_with_witnesses(["alice", "bob"], 2)
        engine = Engine(chain)

        promotion_id = engine.submit_promotion(
            namespace="corp",
            rule_ids=["rule:a", "rule:b"],
            submitter_id="alice"
        )

        assert promotion_id is not None
        assert isinstance(promotion_id, str)
        assert len(promotion_id) == 36  # UUID format

    def test_submit_promotion_stores_request(self):
        """Promotion request is stored internally."""
        chain = create_test_chain_with_witnesses(["alice"], 1)
        engine = Engine(chain)

        promotion_id = engine.submit_promotion(
            namespace="corp",
            rule_ids=["rule:a"],
            submitter_id="alice"
        )

        assert promotion_id in engine._promotions
        pr = engine._promotions[promotion_id]
        assert pr.namespace == "corp"
        assert pr.rule_ids == ("rule:a",)  # tuple!
        assert pr.status == PromotionStatus.PENDING

    def test_submit_promotion_invalid_namespace(self):
        """Invalid namespace raises InputInvalidError."""
        chain = create_test_chain_with_witnesses(["alice"], 1)
        engine = Engine(chain)

        with pytest.raises(InputInvalidError) as exc_info:
            engine.submit_promotion(
                namespace="INVALID!",
                rule_ids=["rule:a"],
                submitter_id="alice"
            )
        assert exc_info.value.code == "DG_INPUT_INVALID"

    def test_submit_promotion_no_witness_set(self):
        """Namespace without WitnessSet raises InputInvalidError."""
        chain = create_test_chain_with_witnesses(["alice"], 1)
        engine = Engine(chain)

        with pytest.raises(InputInvalidError) as exc_info:
            engine.submit_promotion(
                namespace="other",  # Not "corp" - no WitnessSet
                rule_ids=["rule:a"],
                submitter_id="alice"
            )
        assert "No WitnessSet" in exc_info.value.message


class TestCollectWitnessSignature:
    """Tests for Engine.collect_witness_signature() (PRO-02, PRO-05, PRO-06)"""

    def test_collect_signature_updates_status_to_collecting(self):
        """First signature transitions status to COLLECTING."""
        chain = create_test_chain_with_witnesses(["alice", "bob"], 2)
        engine = Engine(chain)
        priv, pub = generate_ed25519_keypair()

        promotion_id = engine.submit_promotion("corp", ["rule:a"], "submitter")
        promotion = engine._promotions[promotion_id]
        signature = sign_bytes(priv, promotion.canonical_payload)

        status = engine.collect_witness_signature(
            promotion_id=promotion_id,
            witness_id="alice",
            signature=signature,
            public_key=pub
        )

        assert status == PromotionStatus.COLLECTING
        assert "alice" in promotion.signatures

    def test_collect_signature_threshold_met(self):
        """Reaching threshold transitions status to THRESHOLD_MET."""
        chain = create_test_chain_with_witnesses(["alice", "bob"], 2)
        engine = Engine(chain)
        alice_priv, alice_pub = generate_ed25519_keypair()
        bob_priv, bob_pub = generate_ed25519_keypair()

        promotion_id = engine.submit_promotion("corp", ["rule:a"], "submitter")
        promotion = engine._promotions[promotion_id]

        # First signature
        sig1 = sign_bytes(alice_priv, promotion.canonical_payload)
        engine.collect_witness_signature(promotion_id, "alice", sig1, alice_pub)

        # Second signature - threshold met
        sig2 = sign_bytes(bob_priv, promotion.canonical_payload)
        status = engine.collect_witness_signature(promotion_id, "bob", sig2, bob_pub)

        assert status == PromotionStatus.THRESHOLD_MET

    def test_collect_signature_unauthorized_witness(self):
        """Witness not in WitnessSet raises UnauthorizedError (PRO-05)."""
        chain = create_test_chain_with_witnesses(["alice", "bob"], 2)
        engine = Engine(chain)
        priv, pub = generate_ed25519_keypair()

        promotion_id = engine.submit_promotion("corp", ["rule:a"], "submitter")
        promotion = engine._promotions[promotion_id]
        signature = sign_bytes(priv, promotion.canonical_payload)

        with pytest.raises(UnauthorizedError) as exc_info:
            engine.collect_witness_signature(
                promotion_id=promotion_id,
                witness_id="charlie",  # Not in WitnessSet
                signature=signature,
                public_key=pub
            )
        assert exc_info.value.code == "DG_UNAUTHORIZED"
        assert "charlie" in exc_info.value.message

    def test_collect_signature_invalid_signature(self):
        """Invalid signature raises SignatureInvalidError (PRO-06)."""
        chain = create_test_chain_with_witnesses(["alice"], 1)
        engine = Engine(chain)
        priv, pub = generate_ed25519_keypair()
        wrong_priv, _ = generate_ed25519_keypair()

        promotion_id = engine.submit_promotion("corp", ["rule:a"], "submitter")
        promotion = engine._promotions[promotion_id]
        # Sign with wrong key
        bad_signature = sign_bytes(wrong_priv, promotion.canonical_payload)

        with pytest.raises(SignatureInvalidError) as exc_info:
            engine.collect_witness_signature(
                promotion_id=promotion_id,
                witness_id="alice",
                signature=bad_signature,
                public_key=pub  # pub doesn't match wrong_priv
            )
        assert exc_info.value.code == "DG_SIGNATURE_INVALID"

    def test_collect_signature_promotion_not_found(self):
        """Unknown promotion_id raises InputInvalidError."""
        chain = create_test_chain_with_witnesses(["alice"], 1)
        engine = Engine(chain)
        priv, pub = generate_ed25519_keypair()

        with pytest.raises(InputInvalidError) as exc_info:
            engine.collect_witness_signature(
                promotion_id="nonexistent-id",
                witness_id="alice",
                signature=b"x" * 64,
                public_key=pub
            )
        assert "not found" in exc_info.value.message

    def test_collect_signature_duplicate_witness_overwrites(self):
        """Same witness submitting again overwrites previous signature."""
        chain = create_test_chain_with_witnesses(["alice", "bob"], 2)
        engine = Engine(chain)
        priv1, pub1 = generate_ed25519_keypair()
        priv2, pub2 = generate_ed25519_keypair()

        promotion_id = engine.submit_promotion("corp", ["rule:a"], "submitter")
        promotion = engine._promotions[promotion_id]

        # First submission
        sig1 = sign_bytes(priv1, promotion.canonical_payload)
        engine.collect_witness_signature(promotion_id, "alice", sig1, pub1)
        first_sig = promotion.signatures["alice"]

        # Second submission with different key (overwrites)
        sig2 = sign_bytes(priv2, promotion.canonical_payload)
        engine.collect_witness_signature(promotion_id, "alice", sig2, pub2)

        assert promotion.signatures["alice"] == sig2
        assert promotion.signatures["alice"] != first_sig
        assert len(promotion.signatures) == 1  # Still just one signature
```

IMPORTANT: Tests must use create_genesis_cell_with_witness_set to set up WitnessSet.
IMPORTANT: Each test generates its own keypair for isolation.
  </action>
  <verify>
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_engine_promotion.py -v
  </verify>
  <done>
All 10+ tests pass, covering submit_promotion, collect_witness_signature, PRO-05, PRO-06.
  </done>
</task>

</tasks>

<verification>
```bash
# Run engine promotion tests
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_engine_promotion.py -v

# Verify submit_promotion works
python -c "
from decisiongraph import Engine, create_chain
from decisiongraph.genesis import create_genesis_cell_with_witness_set
chain = create_chain()
genesis = create_genesis_cell_with_witness_set('G', 'corp', ['alice'], 1)
chain.append(genesis)
engine = Engine(chain)
pid = engine.submit_promotion('corp', ['r1'], 'alice')
print(f'Promotion ID: {pid}')
"

# Run all tests (existing 682 + new promotion tests)
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest --tb=short
```
</verification>

<success_criteria>
1. Engine.submit_promotion() creates PromotionRequest and returns promotion_id
2. Engine.collect_witness_signature() validates authorization first, then verifies signature
3. Unauthorized witness raises UnauthorizedError with DG_UNAUTHORIZED
4. Invalid signature raises SignatureInvalidError with DG_SIGNATURE_INVALID
5. Status transitions correctly: PENDING -> COLLECTING -> THRESHOLD_MET
6. All new tests pass (10+)
7. All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-promotion-workflow/04-02-SUMMARY.md`
</output>
