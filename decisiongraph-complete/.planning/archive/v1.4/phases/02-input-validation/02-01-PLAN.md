---
phase: 02-input-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/decisiongraph/validators.py
  - tests/test_validators.py
autonomous: true

must_haves:
  truths:
    - "Valid subject 'user:alice_123' passes validation"
    - "Invalid subject 'USER:Alice' (uppercase) raises InputInvalidError with DG_INPUT_INVALID"
    - "Valid predicate 'can_access' passes validation"
    - "Invalid predicate 'can access' (space) raises InputInvalidError with DG_INPUT_INVALID"
    - "Object exceeding 4096 chars raises InputInvalidError with DG_INPUT_INVALID"
    - "Control character '\\x00' in any field raises InputInvalidError with DG_INPUT_INVALID"
    - "Tab (\\x09) and newline (\\x0A) in object field are allowed"
    - "All 127 existing tests remain passing"
  artifacts:
    - path: "src/decisiongraph/validators.py"
      provides: "Input validation functions for subject, predicate, object fields"
      exports: ["validate_subject_field", "validate_predicate_field", "validate_object_field", "contains_control_chars", "SUBJECT_PATTERN", "PREDICATE_PATTERN", "CONTROL_CHARS_PATTERN", "MAX_OBJECT_LENGTH"]
    - path: "tests/test_validators.py"
      provides: "Comprehensive tests for all validation functions"
      min_lines: 100
  key_links:
    - from: "src/decisiongraph/validators.py"
      to: "src/decisiongraph/exceptions.py"
      via: "from .exceptions import InputInvalidError"
      pattern: "from \\.exceptions import InputInvalidError"
---

<objective>
Create input validation functions that reject malformed or malicious input before it reaches the core DecisionGraph engine.

Purpose: Security boundary - validate subject, predicate, and object fields at entry points. Malformed input (bad format, control characters, excessive length) is rejected with actionable InputInvalidError messages.

Output:
- `src/decisiongraph/validators.py` - Validation module with pre-compiled regex patterns
- `tests/test_validators.py` - Comprehensive test coverage for all validation scenarios
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-input-validation/02-RESEARCH.md

# Existing code to understand patterns:
@src/decisiongraph/exceptions.py
@src/decisiongraph/cell.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validators.py with pre-compiled regex validation</name>
  <files>src/decisiongraph/validators.py</files>
  <action>
Create `src/decisiongraph/validators.py` implementing input validation for Phase 2 requirements.

**Module structure:**

1. **Pre-compiled regex patterns (module-level constants):**
   - `SUBJECT_PATTERN = re.compile(r'^[a-z_]+:[a-z0-9_./-]{1,128}$')` - VAL-01
   - `PREDICATE_PATTERN = re.compile(r'^[a-z_][a-z0-9_]{0,63}$')` - VAL-02
   - `CONTROL_CHARS_PATTERN = re.compile(r'[\x00-\x08\x0B-\x1F]')` - VAL-04 (excludes tab 0x09 and newline 0x0A)
   - `MAX_OBJECT_LENGTH = 4096` - VAL-03

2. **Helper function:**
   - `contains_control_chars(text: str) -> bool` - Returns True if text contains disallowed control characters

3. **Validation functions (all raise InputInvalidError on failure):**

   **validate_subject_field(subject: str, field_name: str = "subject") -> None:**
   - Check for empty string (raise InputInvalidError)
   - Check for control characters (raise InputInvalidError)
   - Check against SUBJECT_PATTERN using fullmatch() (raise InputInvalidError)
   - Actionable error message: include expected pattern, example, and what was wrong
   - Details dict: `{"field": field_name, "value": subject[:100], "pattern": "...", "constraint": "..."}`

   **validate_predicate_field(predicate: str, field_name: str = "predicate") -> None:**
   - Check for empty string
   - Check for control characters
   - Check against PREDICATE_PATTERN using fullmatch()
   - Actionable error message with pattern and example

   **validate_object_field(obj: str, field_name: str = "object") -> None:**
   - Check for empty string
   - Check length > MAX_OBJECT_LENGTH FIRST (security: prevent huge input processing)
   - Check for control characters
   - Type detection is NOT strict (accept any string <= 4096 chars that passes control char check)
   - Typed IDs and JSON objects are valid; plain strings are valid too

4. **Module docstring:** Reference VAL-01 through VAL-04 requirements

5. **__all__ export:** All public functions and constants

**Key implementation notes from research:**
- Use `fullmatch()` not `match()` to ensure entire string matches (security)
- Control chars pattern `[\x00-\x08\x0B-\x1F]` excludes tab (0x09) and newline (0x0A)
- Truncate value in error details to 100 chars for safety
- Import `InputInvalidError` from `.exceptions` (Phase 1 provides this)
- Patterns are ReDoS-safe (no nested quantifiers)
  </action>
  <verify>
```bash
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete
python -c "from src.decisiongraph.validators import validate_subject_field, validate_predicate_field, validate_object_field, contains_control_chars, SUBJECT_PATTERN, PREDICATE_PATTERN, CONTROL_CHARS_PATTERN, MAX_OBJECT_LENGTH; print('All exports available')"
```
  </verify>
  <done>
- `validators.py` exists with all 3 validation functions + helper
- All constants (SUBJECT_PATTERN, PREDICATE_PATTERN, CONTROL_CHARS_PATTERN, MAX_OBJECT_LENGTH) defined
- Functions raise InputInvalidError with actionable messages
- Module imports work without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive test suite for validators</name>
  <files>tests/test_validators.py</files>
  <action>
Create `tests/test_validators.py` with comprehensive test coverage for all validation functions.

**Test structure (use pytest parametrize for valid/invalid cases):**

1. **TestSubjectValidation class:**

   `test_valid_subjects_accepted(valid_subject)` - parametrized:
   - "user:alice"
   - "user:alice123"
   - "user:alice_123"
   - "user:alice.bob"
   - "user:path/to/resource"
   - "user:a-b-c"
   - "entity_type:id_123"
   - "type:a" + "x" * 127 (exactly 128 chars after colon)
   - "a:b" (minimum valid)

   `test_invalid_subjects_rejected(invalid_subject, reason)` - parametrized:
   - ("", "empty string")
   - ("NoColon", "missing colon")
   - ("type:", "empty identifier")
   - (":identifier", "empty type")
   - ("TYPE:id", "uppercase type")
   - ("type:ID", "uppercase identifier")
   - ("type:id" + "x" * 125, "identifier too long >128")
   - ("type:id\x00", "null byte")
   - ("type:id\x1F", "control char 0x1F")
   - ("type:id name", "space not allowed")
   - ("type:id;DROP TABLE", "semicolon not allowed")
   - ("123:id", "type starts with digit")

   `test_subject_error_is_actionable()` - verify error message contains pattern/example

2. **TestPredicateValidation class:**

   `test_valid_predicates_accepted(valid_predicate)` - parametrized:
   - "can_access"
   - "has_permission"
   - "is_admin"
   - "a"
   - "_private"
   - "x" * 64 (exactly 64 chars)
   - "read123"

   `test_invalid_predicates_rejected(invalid_predicate, reason)` - parametrized:
   - ("", "empty string")
   - ("can access", "space")
   - ("123read", "starts with digit")
   - ("can-access", "hyphen not allowed")
   - ("can.access", "dot not allowed")
   - ("x" * 65, "too long >64")
   - ("pred\x00", "null byte")
   - ("CAN_ACCESS", "uppercase")
   - ("pred;drop", "semicolon")

3. **TestObjectValidation class:**

   `test_valid_objects_accepted(valid_object)` - parametrized:
   - "user:alice" (typed ID)
   - '{"type": "amount", "value": 100}' (TypedValue JSON)
   - "simple string"
   - "string with tab\there" (tab allowed)
   - "string with\nnewline" (newline allowed)
   - "x" * 4096 (exactly max length)

   `test_invalid_objects_rejected(invalid_object, reason)` - parametrized:
   - ("", "empty string")
   - ("x" * 4097, "exceeds 4096 chars")
   - ("value\x00here", "null byte")
   - ("value\x1Fhere", "control char 0x1F")

   `test_object_length_error_includes_length()` - verify error details include actual length

4. **TestControlCharacterDetection class:**

   `test_control_chars_detected()` - check each char in 0x00-0x08, 0x0B-0x1F
   `test_allowed_chars_not_detected()` - check 0x09 (tab) and 0x0A (newline) are allowed
   `test_printable_ascii_not_detected()` - verify normal chars don't trigger

5. **TestErrorCodeIntegration class:**

   `test_subject_error_has_correct_code()` - verify InputInvalidError.code == "DG_INPUT_INVALID"
   `test_predicate_error_has_correct_code()`
   `test_object_error_has_correct_code()`

**Test file structure:**
- Import validators and InputInvalidError
- Use pytest.mark.parametrize for table-driven tests
- Each test class covers one validation function
- Verify error messages are actionable (not just "Invalid")
  </action>
  <verify>
```bash
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete
python -m pytest tests/test_validators.py -v
python -m pytest tests/ -v --tb=short  # All tests including original 127
```
  </verify>
  <done>
- `test_validators.py` exists with all test classes
- All parametrized test cases pass
- Original 127 tests still pass (no regression)
- Total test count increased (should be ~170+ tests)
  </done>
</task>

</tasks>

<verification>
Run the complete test suite to verify no regressions:

```bash
cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete

# Run all tests
python -m pytest tests/ -v --tb=short

# Verify specific requirements
python -c "
from src.decisiongraph.validators import validate_subject_field, validate_predicate_field, validate_object_field
from src.decisiongraph.exceptions import InputInvalidError

# VAL-01: Subject validation
validate_subject_field('user:alice_123')  # Should pass
try:
    validate_subject_field('USER:Alice')
    print('FAIL: Should have rejected uppercase')
except InputInvalidError as e:
    assert e.code == 'DG_INPUT_INVALID'
    print('VAL-01: PASS')

# VAL-02: Predicate validation
validate_predicate_field('can_access')  # Should pass
try:
    validate_predicate_field('can access')
    print('FAIL: Should have rejected space')
except InputInvalidError as e:
    assert e.code == 'DG_INPUT_INVALID'
    print('VAL-02: PASS')

# VAL-03: Object length
try:
    validate_object_field('x' * 4097)
    print('FAIL: Should have rejected >4096 chars')
except InputInvalidError as e:
    assert e.code == 'DG_INPUT_INVALID'
    print('VAL-03: PASS')

# VAL-04: Control characters
try:
    validate_subject_field('user:alice\x00')
    print('FAIL: Should have rejected null byte')
except InputInvalidError as e:
    assert e.code == 'DG_INPUT_INVALID'
    print('VAL-04: PASS')

print('All requirements verified!')
"
```
</verification>

<success_criteria>
1. `validators.py` module exists with all validation functions
2. All 4 VAL requirements implemented (VAL-01 through VAL-04)
3. Validation errors raise InputInvalidError with DG_INPUT_INVALID code
4. Error messages are actionable (include pattern, example, constraint)
5. Test suite covers valid and invalid cases for each field
6. All 127+ existing tests remain passing
7. New tests pass (test_validators.py)
</success_criteria>

<output>
After completion, create `.planning/phases/02-input-validation/02-01-SUMMARY.md`
</output>
