---
phase: 05-adversarial-test-suite
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/test_adversarial_integrity.py
  - tests/test_adversarial_tampering.py
  - tests/test_adversarial_authorization.py
autonomous: true

must_haves:
  truths:
    - "Cross-graph cell contamination fails with DG_INTEGRITY_FAIL"
    - "ProofPacket with 1 byte modified fails verification"
    - "Bridge time-travel queries fail with DG_UNAUTHORIZED"
    - "Existing 342 tests remain passing"
  artifacts:
    - path: "tests/test_adversarial_integrity.py"
      provides: "SEC-03 cross-graph contamination tests"
      min_lines: 50
    - path: "tests/test_adversarial_tampering.py"
      provides: "SEC-04 signature tampering tests"
      min_lines: 80
    - path: "tests/test_adversarial_authorization.py"
      provides: "SEC-05 bridge time-travel tests"
      min_lines: 50
  key_links:
    - from: "tests/test_adversarial_integrity.py"
      to: "decisiongraph.chain"
      via: "Chain.append() with mismatched graph_id"
      pattern: "GraphIdMismatch|IntegrityFailError"
    - from: "tests/test_adversarial_tampering.py"
      to: "decisiongraph.engine"
      via: "verify_proof_packet with tampered signature"
      pattern: "verify_proof_packet.*False"
    - from: "tests/test_adversarial_authorization.py"
      to: "decisiongraph.scholar"
      via: "query with as_of_system_time before bridge"
      pattern: "as_of_system_time|UnauthorizedError"
---

<objective>
Create adversarial test files for security layer attack vectors (SEC-03, SEC-04, SEC-05).

Purpose: Prove that integrity violations, signature tampering, and authorization bypasses are detected with deterministic error codes or boolean failure responses.

Output: Three test files covering cross-graph contamination, signature tampering, and bridge time-travel attacks.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-adversarial-test-suite/05-RESEARCH.md

# Source files being tested
@src/decisiongraph/chain.py
@src/decisiongraph/signing.py
@src/decisiongraph/engine.py
@src/decisiongraph/scholar.py

# Existing test patterns
@tests/test_signing.py
@tests/test_engine.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SEC-03 cross-graph integrity tests</name>
  <files>tests/test_adversarial_integrity.py</files>
  <action>
Create test_adversarial_integrity.py with cross-graph contamination tests.

Structure:
```python
"""
Adversarial Test Suite: Cross-Graph Integrity (SEC-03)

Tests that cells from different graphs cannot contaminate each other.
Cross-graph operations must fail with DG_INTEGRITY_FAIL.
"""

import pytest
from decisiongraph import (
    create_chain,
    IntegrityFailError,
    GraphIdMismatch,
    DecisionCell,
    Header,
    Fact,
    LogicAnchor,
    Proof,
    CellType,
    get_current_timestamp,
    NULL_HASH
)
from decisiongraph.exceptions import wrap_internal_exception
```

Class TestCrossGraphContamination:
- test_cell_with_different_graph_id_rejected:
  1. Create chain_a = create_chain("graph_a")
  2. Create chain_b = create_chain("graph_b")
  3. Create a cell with graph_id=chain_a.graph_id
  4. Attempt chain_b.append(cell_from_a)
  5. Assert raises GraphIdMismatch (internal) or IntegrityFailError (wrapped)
  6. Verify error message mentions "graph_id"

- test_cell_graph_id_mismatch_error_code:
  1. Same setup as above
  2. Wrap the GraphIdMismatch in wrap_internal_exception()
  3. Verify wrapped error has code == "DG_INTEGRITY_FAIL"

- test_modify_cell_graph_id_after_creation:
  1. Create cell with valid graph_id
  2. Attempt to modify graph_id (cells are dataclasses, so this may work)
  3. If modification succeeds, verify_integrity() should fail
  4. Chain.append() should reject based on integrity check

Class TestIntegrityViolationDetection:
- Parametrized tests for various integrity violations:
  - Modified cell_id
  - Modified prev_cell_hash
  - Modified content after cell creation
- All should fail with appropriate error

IMPORTANT: The existing Chain.append() raises GraphIdMismatch (internal exception).
At API boundary, this wraps to IntegrityFailError with code DG_INTEGRITY_FAIL.
Test BOTH the internal exception AND the wrapped error code.
  </action>
  <verify>pytest tests/test_adversarial_integrity.py -v passes with all tests green</verify>
  <done>
    - test_adversarial_integrity.py exists with 2 test classes
    - Cell from different graph_id rejected by Chain.append()
    - GraphIdMismatch wraps to DG_INTEGRITY_FAIL
    - Cross-graph contamination attack proven to fail
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SEC-04 signature tampering tests</name>
  <files>tests/test_adversarial_tampering.py</files>
  <action>
Create test_adversarial_tampering.py with signature/packet tampering tests.

Structure:
```python
"""
Adversarial Test Suite: Signature Tampering (SEC-04)

Tests that signature tampering is detected. Modified signatures or data
must fail verification (return False, not exception for invalid signatures).
"""

import pytest
import base64
from decisiongraph import (
    create_chain,
    process_rfa,
    verify_proof_packet,
    sign_bytes,
    verify_signature,
    generate_ed25519_keypair,
    SignatureInvalidError
)
```

Class TestSignatureTampering:
- test_single_bit_flip_detected:
  1. priv, pub = generate_ed25519_keypair()
  2. signature = sign_bytes(priv, b"important data")
  3. Tamper: flip last bit (signature[-1] ^ 0x01)
  4. verify_signature(pub, data, tampered_sig) returns False

- Parametrized test_byte_modification_at_position with positions [0, 31, 32, 63]:
  1. Generate keypair and sign data
  2. Modify byte at specific position (XOR with 0xFF)
  3. verify_signature returns False

- test_data_modification_detected:
  1. Sign original data
  2. Modify data by 1 byte
  3. verify_signature(pub, modified_data, original_sig) returns False

Class TestProofPacketTampering:
- test_proof_packet_signature_byte_flip:
  1. Create chain and RFA
  2. packet = process_rfa(chain, rfa, signing_key=priv, public_key=pub)
  3. Tamper: decode base64 signature, flip 1 byte, re-encode
  4. verify_proof_packet(tampered_packet, pub) returns False

- test_proof_packet_proof_bundle_modification:
  1. Create signed packet
  2. Modify proof_bundle content
  3. verify_proof_packet returns False (signature no longer matches)

- Parametrized test_various_tampering_methods:
  - flip_first_byte
  - flip_last_byte
  - flip_middle_byte
  - truncate_signature
  - append_byte
  All should return False from verify_proof_packet

IMPORTANT: Per research, verify_signature() and verify_proof_packet() return False
for invalid signatures (normal control flow). Only format errors raise exceptions.
  </action>
  <verify>pytest tests/test_adversarial_tampering.py -v passes with all tests green</verify>
  <done>
    - test_adversarial_tampering.py exists with 2 test classes
    - Single bit flip in signature detected (returns False)
    - Byte modifications at various positions detected
    - ProofPacket tampering detected by verify_proof_packet()
    - All tampering methods return False (not exception)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create SEC-05 bridge time-travel tests</name>
  <files>tests/test_adversarial_authorization.py</files>
  <action>
Create test_adversarial_authorization.py with bridge time-travel attack tests.

Structure:
```python
"""
Adversarial Test Suite: Bridge Time-Travel (SEC-05)

Tests that queries using as_of_system_time cannot bypass authorization
by querying a point in time before the bridge was created.
"""

import pytest
from datetime import datetime, timezone, timedelta
from decisiongraph import (
    create_chain,
    create_scholar,
    process_rfa,
    UnauthorizedError,
    AccessDeniedError,
    BridgeRequiredError,
    create_namespace_definition,
    create_bridge_rule,
    get_current_timestamp
)
```

Class TestBridgeTimeTravelAttack:
- test_query_before_bridge_creation_fails:
  1. Create chain with genesis at time T0
  2. Add namespace definitions for corp.hr and corp.audit
  3. Add some facts to corp.hr at time T1
  4. Create bridge from corp.audit to corp.hr at time T2 (T2 > T1)
  5. Query from corp.audit with as_of_system_time=T1 (before bridge)
  6. Should fail with DG_UNAUTHORIZED (bridge not effective at that time)

- test_query_after_bridge_creation_succeeds:
  1. Same setup as above
  2. Query with as_of_system_time=T3 (after bridge, T3 > T2)
  3. Should succeed (bridge is effective)

- test_time_travel_to_before_namespace_exists:
  1. Create chain
  2. Add namespace at time T1
  3. Query with as_of_system_time=T0 (before namespace)
  4. Should fail with appropriate error

Class TestAuthorizationBypassAttempts:
- test_cross_namespace_without_bridge_fails:
  1. Create chain with two namespaces (no bridge)
  2. Query from namespace A to namespace B
  3. Should fail with DG_UNAUTHORIZED or BridgeRequiredError

- test_revoked_bridge_blocks_access:
  1. Create bridge, then revoke it
  2. Query after revocation
  3. Should fail with DG_UNAUTHORIZED

IMPORTANT: Need to understand bridge temporal logic from Phase 4.
The bridge has a valid_from and valid_to (or None for forever).
Query with as_of_system_time must be within bridge validity period.
If this logic isn't implemented, test may need to verify the error type
that IS returned (could be AccessDeniedError, BridgeRequiredError, etc.)
which should all wrap to DG_UNAUTHORIZED.
  </action>
  <verify>pytest tests/test_adversarial_authorization.py -v passes with all tests green</verify>
  <done>
    - test_adversarial_authorization.py exists with 2 test classes
    - Query with as_of_system_time before bridge creation fails
    - Authorization bypass attempts fail with DG_UNAUTHORIZED
    - Cross-namespace queries without bridge fail
    - Bridge revocation is respected
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. SEC-03 verification:
   - `pytest tests/test_adversarial_integrity.py -v` shows all integrity tests pass
   - Cell from different graph fails with DG_INTEGRITY_FAIL

2. SEC-04 verification:
   - `pytest tests/test_adversarial_tampering.py -v` shows all tampering tests pass
   - ProofPacket with 1 byte modified fails verification (returns False)

3. SEC-05 verification:
   - `pytest tests/test_adversarial_authorization.py -v` shows all auth tests pass
   - Query before bridge creation fails with DG_UNAUTHORIZED

4. Regression check:
   - `pytest tests/ --tb=short` shows all tests pass
   - Test count > 342
</verification>

<success_criteria>
- [ ] test_adversarial_integrity.py created with SEC-03 tests
- [ ] test_adversarial_tampering.py created with SEC-04 tests
- [ ] test_adversarial_authorization.py created with SEC-05 tests
- [ ] Cross-graph contamination returns DG_INTEGRITY_FAIL
- [ ] Signature tampering detected (verify_* returns False)
- [ ] Bridge time-travel returns DG_UNAUTHORIZED
- [ ] Existing 342 tests remain passing
- [ ] Total test count > 342 (with both plans complete)
</success_criteria>

<output>
After completion, create `.planning/phases/05-adversarial-test-suite/05-02-SUMMARY.md`
</output>
