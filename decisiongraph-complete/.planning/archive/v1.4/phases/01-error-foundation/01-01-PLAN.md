---
phase: 01-error-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/decisiongraph/exceptions.py
  - src/decisiongraph/__init__.py
autonomous: true

must_haves:
  truths:
    - "DecisionGraphError can be raised with code, message, and details"
    - "Six error subclasses exist with distinct DG_* codes"
    - "All errors serialize to JSON with code, message, details fields"
  artifacts:
    - path: "src/decisiongraph/exceptions.py"
      provides: "DecisionGraphError base class and 6 subclasses"
      exports: ["DecisionGraphError", "SchemaInvalidError", "InputInvalidError", "UnauthorizedError", "IntegrityFailError", "SignatureInvalidError", "InternalError"]
    - path: "src/decisiongraph/__init__.py"
      provides: "Public exports for new exception classes"
      contains: "from .exceptions import"
  key_links:
    - from: "src/decisiongraph/__init__.py"
      to: "src/decisiongraph/exceptions.py"
      via: "import statement"
      pattern: "from \\.exceptions import"
---

<objective>
Create the DecisionGraphError exception hierarchy with 6 domain-specific error codes.

Purpose: Provide external developers with deterministic, actionable error codes from any DecisionGraph failure. This is the foundation for all error handling in the RFA layer.

Output: New `exceptions.py` module with base class and 6 subclasses, exported via `__init__.py`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-error-foundation/01-RESEARCH.md

# Existing codebase
@src/decisiongraph/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create exceptions.py with DecisionGraphError hierarchy</name>
  <files>src/decisiongraph/exceptions.py</files>
  <action>
Create a new file `src/decisiongraph/exceptions.py` with:

1. **DecisionGraphError base class:**
   - Class attribute `code = "DG_INTERNAL_ERROR"` (default)
   - `__init__(self, message: str, details: Optional[Dict[str, Any]] = None, request_id: Optional[str] = None)`
   - Store `message`, `details` (default to empty dict), `request_id` as instance attributes
   - Call `super().__init__(message)` to set args[0]
   - `to_dict() -> Dict[str, Any]` returns `{"code": self.code, "message": self.message, "details": self.details}` (include request_id if present)
   - `to_json(indent: Optional[int] = None) -> str` returns `json.dumps(self.to_dict(), indent=indent)`
   - `__str__` returns `f"[{self.code}] {self.message}"`
   - `__repr__` returns developer-friendly representation

2. **Six subclasses** (each only overrides class attribute `code`):
   - `SchemaInvalidError(DecisionGraphError)` with `code = "DG_SCHEMA_INVALID"`
   - `InputInvalidError(DecisionGraphError)` with `code = "DG_INPUT_INVALID"`
   - `UnauthorizedError(DecisionGraphError)` with `code = "DG_UNAUTHORIZED"`
   - `IntegrityFailError(DecisionGraphError)` with `code = "DG_INTEGRITY_FAIL"`
   - `SignatureInvalidError(DecisionGraphError)` with `code = "DG_SIGNATURE_INVALID"`
   - `InternalError(DecisionGraphError)` with `code = "DG_INTERNAL_ERROR"` (explicit fallback)

3. Add docstrings explaining each error code's purpose:
   - DG_SCHEMA_INVALID: Schema validation failed (missing fields, wrong types)
   - DG_INPUT_INVALID: Input validation failed (bad format, out of bounds)
   - DG_UNAUTHORIZED: Access denied (no permission, no bridge)
   - DG_INTEGRITY_FAIL: Integrity check failed (hash mismatch, chain break)
   - DG_SIGNATURE_INVALID: Cryptographic signature invalid or missing
   - DG_INTERNAL_ERROR: Unexpected internal error (catch-all)

4. Add `__all__` export list

Use typing imports: `from typing import Any, Optional, Dict`
Use json import for serialization
  </action>
  <verify>
```bash
python -c "from src.decisiongraph.exceptions import DecisionGraphError, SchemaInvalidError, InputInvalidError, UnauthorizedError, IntegrityFailError, SignatureInvalidError, InternalError; e = SchemaInvalidError('test', {'field': 'x'}); print(e.to_dict()); print(e.to_json())"
```
Should print: `{'code': 'DG_SCHEMA_INVALID', 'message': 'test', 'details': {'field': 'x'}}`
  </verify>
  <done>
- DecisionGraphError base class exists with code, message, details attributes
- to_dict() and to_json() methods work correctly
- Six subclasses exist with distinct DG_* codes
- All classes are importable from exceptions.py
  </done>
</task>

<task type="auto">
  <name>Task 2: Export exceptions from package __init__.py</name>
  <files>src/decisiongraph/__init__.py</files>
  <action>
Add the new exceptions to `src/decisiongraph/__init__.py`:

1. Add import block after existing imports (before `__all__`):
```python
# Exceptions (v1.4)
from .exceptions import (
    DecisionGraphError,
    SchemaInvalidError,
    InputInvalidError,
    UnauthorizedError,
    IntegrityFailError,
    SignatureInvalidError,
    InternalError
)
```

2. Add to `__all__` list (add a new comment section):
```python
    # Exceptions (v1.4)
    'DecisionGraphError', 'SchemaInvalidError', 'InputInvalidError',
    'UnauthorizedError', 'IntegrityFailError', 'SignatureInvalidError',
    'InternalError',
```

Do NOT modify any existing imports or exports - only add the new ones.
  </action>
  <verify>
```bash
python -c "from src.decisiongraph import DecisionGraphError, SchemaInvalidError; print('Exports work:', SchemaInvalidError.code)"
```
Should print: `Exports work: DG_SCHEMA_INVALID`
  </verify>
  <done>
- All 7 exception classes exported from package
- Existing 69 tests still pass (run `pytest tests/` to confirm)
  </done>
</task>

</tasks>

<verification>
```bash
# Verify exception hierarchy
python -c "
from src.decisiongraph import (
    DecisionGraphError, SchemaInvalidError, InputInvalidError,
    UnauthorizedError, IntegrityFailError, SignatureInvalidError, InternalError
)

# Check inheritance
assert issubclass(SchemaInvalidError, DecisionGraphError)
assert issubclass(InputInvalidError, DecisionGraphError)
assert issubclass(UnauthorizedError, DecisionGraphError)
assert issubclass(IntegrityFailError, DecisionGraphError)
assert issubclass(SignatureInvalidError, DecisionGraphError)
assert issubclass(InternalError, DecisionGraphError)

# Check codes
assert SchemaInvalidError.code == 'DG_SCHEMA_INVALID'
assert InputInvalidError.code == 'DG_INPUT_INVALID'
assert UnauthorizedError.code == 'DG_UNAUTHORIZED'
assert IntegrityFailError.code == 'DG_INTEGRITY_FAIL'
assert SignatureInvalidError.code == 'DG_SIGNATURE_INVALID'
assert InternalError.code == 'DG_INTERNAL_ERROR'

# Check serialization
e = IntegrityFailError('Hash mismatch', {'cell_id': 'abc123'}, request_id='req_001')
d = e.to_dict()
assert d['code'] == 'DG_INTEGRITY_FAIL'
assert d['message'] == 'Hash mismatch'
assert d['details']['cell_id'] == 'abc123'
assert d['request_id'] == 'req_001'

import json
j = e.to_json()
assert json.loads(j) == d

print('All exception hierarchy checks passed!')
"

# Verify existing tests still pass
pytest tests/ -q
```
</verification>

<success_criteria>
1. DecisionGraphError base class exists with `.code`, `.message`, `.details` attributes (ERR-01)
2. Six subclasses exist with distinct DG_* codes
3. `to_dict()` returns JSON-compatible dict with code, message, details
4. `to_json()` returns valid JSON string
5. All exception classes importable from `src.decisiongraph`
6. Existing 69 tests remain passing
</success_criteria>

<output>
After completion, create `.planning/phases/01-error-foundation/01-01-SUMMARY.md`
</output>
