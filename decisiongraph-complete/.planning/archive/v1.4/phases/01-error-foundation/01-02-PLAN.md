---
phase: 01-error-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/decisiongraph/exceptions.py
autonomous: true

must_haves:
  truths:
    - "Internal exceptions can be mapped to DecisionGraphError subclasses"
    - "Exception chaining preserves original traceback"
    - "All existing exception types have a mapping"
  artifacts:
    - path: "src/decisiongraph/exceptions.py"
      provides: "EXCEPTION_MAP and wrap_internal_exception function"
      exports: ["EXCEPTION_MAP", "wrap_internal_exception"]
  key_links:
    - from: "src/decisiongraph/exceptions.py"
      to: "src/decisiongraph/chain.py"
      via: "EXCEPTION_MAP references ChainError types"
      pattern: "IntegrityViolation|ChainBreak|GenesisViolation"
    - from: "src/decisiongraph/exceptions.py"
      to: "src/decisiongraph/namespace.py"
      via: "EXCEPTION_MAP references NamespaceError types"
      pattern: "AccessDeniedError|BridgeRequiredError"
---

<objective>
Create the exception mapping system that converts internal exceptions to external DecisionGraphError types.

Purpose: Enable the RFA layer (Phase 4) to catch internal exceptions and wrap them with appropriate DG_* error codes while preserving traceback information for debugging.

Output: EXCEPTION_MAP dictionary and wrap_internal_exception() helper function in exceptions.py.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-error-foundation/01-RESEARCH.md
@.planning/phases/01-error-foundation/01-01-SUMMARY.md

# Exception sources to map
@src/decisiongraph/chain.py
@src/decisiongraph/namespace.py
@src/decisiongraph/genesis.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EXCEPTION_MAP and wrap_internal_exception to exceptions.py</name>
  <files>src/decisiongraph/exceptions.py</files>
  <action>
Add to `src/decisiongraph/exceptions.py` (after the exception class definitions, before `__all__`):

1. **Import internal exception types** (add at top of file after typing imports):
```python
# Import internal exceptions for mapping
# These are imported here to build the mapping; they remain the canonical
# exceptions used internally. DecisionGraphError wraps them at API boundaries.
from .chain import (
    ChainError, IntegrityViolation, ChainBreak,
    GenesisViolation, TemporalViolation, GraphIdMismatch
)
from .namespace import (
    NamespaceError, AccessDeniedError, BridgeRequiredError, BridgeApprovalError
)
from .genesis import GenesisError, GenesisValidationError
```

2. **Create EXCEPTION_MAP** (maps internal exception types to DecisionGraphError subclasses):
```python
# Exception mapping: internal exceptions -> external error codes
# Used by wrap_internal_exception() at API boundaries
EXCEPTION_MAP: Dict[type, type] = {
    # Chain errors -> DG_INTEGRITY_FAIL
    IntegrityViolation: IntegrityFailError,
    ChainBreak: IntegrityFailError,
    TemporalViolation: IntegrityFailError,
    GraphIdMismatch: IntegrityFailError,

    # Genesis errors -> DG_SCHEMA_INVALID
    GenesisError: SchemaInvalidError,
    GenesisValidationError: SchemaInvalidError,
    GenesisViolation: SchemaInvalidError,

    # Namespace/access errors -> DG_UNAUTHORIZED
    AccessDeniedError: UnauthorizedError,
    BridgeRequiredError: UnauthorizedError,
    BridgeApprovalError: UnauthorizedError,

    # Base classes map to their category (fallback)
    ChainError: IntegrityFailError,
    NamespaceError: UnauthorizedError,

    # ValueError (from cell.py) -> DG_INPUT_INVALID
    ValueError: InputInvalidError,

    # TypeError -> DG_INPUT_INVALID
    TypeError: InputInvalidError,
}
```

3. **Create wrap_internal_exception function**:
```python
def wrap_internal_exception(
    exc: Exception,
    default_message: Optional[str] = None,
    details: Optional[Dict[str, Any]] = None,
    request_id: Optional[str] = None
) -> DecisionGraphError:
    """
    Wrap an internal exception as a DecisionGraphError.

    Automatically maps known exception types to appropriate error codes
    using EXCEPTION_MAP. Unknown exceptions map to InternalError.

    IMPORTANT: Use with exception chaining to preserve traceback:
        try:
            internal_operation()
        except SomeInternalError as e:
            raise wrap_internal_exception(e, details={...}) from e

    Args:
        exc: The internal exception to wrap
        default_message: Override message (uses str(exc) if None)
        details: Additional structured details to include
        request_id: Optional request ID for tracing

    Returns:
        Appropriate DecisionGraphError subclass instance

    Example:
        try:
            chain.append(cell)
        except IntegrityViolation as e:
            raise wrap_internal_exception(
                e,
                details={"cell_id": cell.cell_id[:16]}
            ) from e
    """
    # Find the appropriate error class
    error_class = EXCEPTION_MAP.get(type(exc), InternalError)

    # Build details dict, including original error type for debugging
    error_details = details.copy() if details else {}
    error_details["internal_error"] = type(exc).__name__

    # If the original exception has additional context, include it
    if hasattr(exc, 'failed_checks'):
        error_details["failed_checks"] = exc.failed_checks

    # Create wrapper exception
    return error_class(
        message=default_message or str(exc),
        details=error_details,
        request_id=request_id
    )
```

4. **Update `__all__`** to include new exports:
```python
__all__ = [
    # Exception classes
    'DecisionGraphError',
    'SchemaInvalidError',
    'InputInvalidError',
    'UnauthorizedError',
    'IntegrityFailError',
    'SignatureInvalidError',
    'InternalError',
    # Mapping utilities
    'EXCEPTION_MAP',
    'wrap_internal_exception',
]
```

Note: The imports from chain.py, namespace.py, genesis.py may cause circular import issues. If so, use TYPE_CHECKING guard:
```python
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from .chain import ...
```
And populate EXCEPTION_MAP lazily or after module load.

Actually, to avoid circular imports, define EXCEPTION_MAP as a function that returns the dict on first call (lazy initialization), or import the exception types inside the function body.
  </action>
  <verify>
```bash
python -c "
from src.decisiongraph.exceptions import EXCEPTION_MAP, wrap_internal_exception, IntegrityFailError
from src.decisiongraph.chain import IntegrityViolation

# Test mapping
assert EXCEPTION_MAP[IntegrityViolation] == IntegrityFailError

# Test wrapping
internal_exc = IntegrityViolation('Hash mismatch')
wrapped = wrap_internal_exception(internal_exc, details={'cell_id': 'abc'})
assert wrapped.code == 'DG_INTEGRITY_FAIL'
assert 'Hash mismatch' in wrapped.message
assert wrapped.details['internal_error'] == 'IntegrityViolation'
assert wrapped.details['cell_id'] == 'abc'

print('Exception mapping works!')
"
```
  </verify>
  <done>
- EXCEPTION_MAP contains all 12 internal exception types
- wrap_internal_exception returns correct subclass for each internal type
- Unknown exceptions map to InternalError
- Original exception type name included in details
- Existing 69 tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Update __init__.py to export mapping utilities</name>
  <files>src/decisiongraph/__init__.py</files>
  <action>
Update the exceptions import block in `src/decisiongraph/__init__.py` to include the new exports:

Find the existing line:
```python
from .exceptions import (
    DecisionGraphError,
    SchemaInvalidError,
    ...
)
```

Add `EXCEPTION_MAP` and `wrap_internal_exception` to the import list.

Also add them to `__all__` in the Exceptions section:
```python
    'EXCEPTION_MAP', 'wrap_internal_exception',
```
  </action>
  <verify>
```bash
python -c "from src.decisiongraph import EXCEPTION_MAP, wrap_internal_exception; print('Package exports:', len(EXCEPTION_MAP), 'mappings')"
```
Should print: `Package exports: N mappings` (where N >= 12)
  </verify>
  <done>
- EXCEPTION_MAP and wrap_internal_exception exported from package
- Existing 69 tests still pass
  </done>
</task>

</tasks>

<verification>
```bash
# Verify all internal exceptions map correctly
python -c "
from src.decisiongraph import (
    EXCEPTION_MAP, wrap_internal_exception,
    SchemaInvalidError, InputInvalidError, UnauthorizedError,
    IntegrityFailError, InternalError
)
from src.decisiongraph.chain import (
    ChainError, IntegrityViolation, ChainBreak,
    GenesisViolation, TemporalViolation, GraphIdMismatch
)
from src.decisiongraph.namespace import (
    NamespaceError, AccessDeniedError, BridgeRequiredError, BridgeApprovalError
)
from src.decisiongraph.genesis import GenesisError, GenesisValidationError

# Verify all mappings exist
mappings = [
    (IntegrityViolation, IntegrityFailError),
    (ChainBreak, IntegrityFailError),
    (TemporalViolation, IntegrityFailError),
    (GraphIdMismatch, IntegrityFailError),
    (ChainError, IntegrityFailError),
    (GenesisError, SchemaInvalidError),
    (GenesisValidationError, SchemaInvalidError),
    (GenesisViolation, SchemaInvalidError),
    (AccessDeniedError, UnauthorizedError),
    (BridgeRequiredError, UnauthorizedError),
    (BridgeApprovalError, UnauthorizedError),
    (NamespaceError, UnauthorizedError),
    (ValueError, InputInvalidError),
    (TypeError, InputInvalidError),
]

for internal, external in mappings:
    assert EXCEPTION_MAP[internal] == external, f'{internal.__name__} should map to {external.__name__}'

# Test wrap_internal_exception with each type
for internal, external in mappings[:5]:  # Test a few
    exc = internal('test message')
    wrapped = wrap_internal_exception(exc)
    assert isinstance(wrapped, external), f'wrapped {internal.__name__} should be {external.__name__}'
    assert wrapped.details['internal_error'] == internal.__name__

# Test unknown exception falls back to InternalError
class CustomError(Exception): pass
wrapped = wrap_internal_exception(CustomError('oops'))
assert isinstance(wrapped, InternalError)
assert wrapped.code == 'DG_INTERNAL_ERROR'

print('All exception mapping tests passed!')
"

# Verify exception chaining preserves traceback
python -c "
from src.decisiongraph import wrap_internal_exception, IntegrityFailError
from src.decisiongraph.chain import IntegrityViolation

try:
    try:
        raise IntegrityViolation('Original error')
    except IntegrityViolation as e:
        raise wrap_internal_exception(e) from e
except IntegrityFailError as wrapped:
    assert wrapped.__cause__ is not None
    assert isinstance(wrapped.__cause__, IntegrityViolation)
    assert 'Original error' in str(wrapped.__cause__)
    print('Exception chaining preserves traceback!')
"

# Verify existing tests still pass
pytest tests/ -q
```
</verification>

<success_criteria>
1. EXCEPTION_MAP contains mappings for all 12+ internal exception types (ERR-02)
2. wrap_internal_exception correctly maps each type
3. Unknown exceptions fall back to InternalError
4. Exception chaining with `raise ... from e` preserves traceback
5. Original exception type included in details.internal_error
6. All utilities exported from package
7. Existing 69 tests remain passing
</success_criteria>

<output>
After completion, create `.planning/phases/01-error-foundation/01-02-SUMMARY.md`
</output>
