---
phase: 01-error-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - tests/test_exceptions.py
autonomous: true

must_haves:
  truths:
    - "Exception behavior is tested and documented"
    - "Serialization produces valid JSON"
    - "All error codes have test coverage"
  artifacts:
    - path: "tests/test_exceptions.py"
      provides: "Comprehensive tests for exception hierarchy"
      min_lines: 100
  key_links:
    - from: "tests/test_exceptions.py"
      to: "src/decisiongraph/exceptions.py"
      via: "pytest imports and tests"
      pattern: "from src\\.decisiongraph import.*DecisionGraphError"
---

<objective>
Create comprehensive tests for the exception hierarchy and mapping system.

Purpose: Ensure the error system works correctly, documenting expected behavior through tests. Verify that the new exceptions integrate cleanly with existing code without breaking the 69 existing tests.

Output: New test file `tests/test_exceptions.py` with full coverage of exception behavior.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-error-foundation/01-01-SUMMARY.md
@.planning/phases/01-error-foundation/01-02-SUMMARY.md

# Reference for test patterns
@tests/test_core.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_exceptions.py with comprehensive tests</name>
  <files>tests/test_exceptions.py</files>
  <action>
Create `tests/test_exceptions.py` with the following test classes:

```python
"""
Tests for DecisionGraph exception hierarchy and mapping.

These tests verify:
1. Exception classes exist with correct error codes
2. Serialization produces valid JSON
3. Exception mapping works correctly
4. Exception chaining preserves tracebacks
"""

import pytest
import json
from src.decisiongraph import (
    DecisionGraphError,
    SchemaInvalidError,
    InputInvalidError,
    UnauthorizedError,
    IntegrityFailError,
    SignatureInvalidError,
    InternalError,
    EXCEPTION_MAP,
    wrap_internal_exception,
)
from src.decisiongraph.chain import (
    ChainError, IntegrityViolation, ChainBreak,
    GenesisViolation, TemporalViolation, GraphIdMismatch
)
from src.decisiongraph.namespace import (
    NamespaceError, AccessDeniedError, BridgeRequiredError, BridgeApprovalError
)
from src.decisiongraph.genesis import GenesisError, GenesisValidationError


class TestDecisionGraphError:
    """Tests for the base DecisionGraphError class."""

    def test_error_has_code_attribute(self):
        """ERR-01: DecisionGraphError has .code attribute."""
        error = DecisionGraphError("test message")
        assert hasattr(error, 'code')
        assert error.code == "DG_INTERNAL_ERROR"

    def test_error_has_message_attribute(self):
        """ERR-01: DecisionGraphError has .message attribute."""
        error = DecisionGraphError("test message")
        assert hasattr(error, 'message')
        assert error.message == "test message"

    def test_error_has_details_attribute(self):
        """ERR-01: DecisionGraphError has .details attribute."""
        error = DecisionGraphError("test", details={"key": "value"})
        assert hasattr(error, 'details')
        assert error.details == {"key": "value"}

    def test_error_details_default_empty_dict(self):
        """Details defaults to empty dict if not provided."""
        error = DecisionGraphError("test")
        assert error.details == {}

    def test_error_request_id_optional(self):
        """Request ID is optional and included when provided."""
        error = DecisionGraphError("test", request_id="req_123")
        assert error.request_id == "req_123"

    def test_error_is_exception(self):
        """DecisionGraphError is a proper Exception subclass."""
        error = DecisionGraphError("test")
        assert isinstance(error, Exception)
        with pytest.raises(DecisionGraphError):
            raise error

    def test_error_str_includes_code(self):
        """String representation includes error code."""
        error = SchemaInvalidError("bad schema")
        assert "[DG_SCHEMA_INVALID]" in str(error)
        assert "bad schema" in str(error)


class TestErrorSubclasses:
    """Tests for the 6 error code subclasses."""

    def test_schema_invalid_error_code(self):
        """SchemaInvalidError has DG_SCHEMA_INVALID code."""
        error = SchemaInvalidError("test")
        assert error.code == "DG_SCHEMA_INVALID"
        assert isinstance(error, DecisionGraphError)

    def test_input_invalid_error_code(self):
        """InputInvalidError has DG_INPUT_INVALID code."""
        error = InputInvalidError("test")
        assert error.code == "DG_INPUT_INVALID"
        assert isinstance(error, DecisionGraphError)

    def test_unauthorized_error_code(self):
        """UnauthorizedError has DG_UNAUTHORIZED code."""
        error = UnauthorizedError("test")
        assert error.code == "DG_UNAUTHORIZED"
        assert isinstance(error, DecisionGraphError)

    def test_integrity_fail_error_code(self):
        """IntegrityFailError has DG_INTEGRITY_FAIL code."""
        error = IntegrityFailError("test")
        assert error.code == "DG_INTEGRITY_FAIL"
        assert isinstance(error, DecisionGraphError)

    def test_signature_invalid_error_code(self):
        """SignatureInvalidError has DG_SIGNATURE_INVALID code."""
        error = SignatureInvalidError("test")
        assert error.code == "DG_SIGNATURE_INVALID"
        assert isinstance(error, DecisionGraphError)

    def test_internal_error_code(self):
        """InternalError has DG_INTERNAL_ERROR code."""
        error = InternalError("test")
        assert error.code == "DG_INTERNAL_ERROR"
        assert isinstance(error, DecisionGraphError)

    def test_all_six_codes_distinct(self):
        """All 6 error codes are distinct."""
        codes = {
            SchemaInvalidError.code,
            InputInvalidError.code,
            UnauthorizedError.code,
            IntegrityFailError.code,
            SignatureInvalidError.code,
            InternalError.code,
        }
        assert len(codes) == 6


class TestErrorSerialization:
    """Tests for JSON serialization of errors."""

    def test_to_dict_includes_code(self):
        """to_dict() includes code field."""
        error = SchemaInvalidError("test")
        d = error.to_dict()
        assert "code" in d
        assert d["code"] == "DG_SCHEMA_INVALID"

    def test_to_dict_includes_message(self):
        """to_dict() includes message field."""
        error = SchemaInvalidError("test message")
        d = error.to_dict()
        assert "message" in d
        assert d["message"] == "test message"

    def test_to_dict_includes_details(self):
        """to_dict() includes details field."""
        error = SchemaInvalidError("test", details={"field": "value"})
        d = error.to_dict()
        assert "details" in d
        assert d["details"]["field"] == "value"

    def test_to_dict_includes_request_id_when_present(self):
        """to_dict() includes request_id when provided."""
        error = SchemaInvalidError("test", request_id="req_abc")
        d = error.to_dict()
        assert "request_id" in d
        assert d["request_id"] == "req_abc"

    def test_to_dict_excludes_request_id_when_none(self):
        """to_dict() excludes request_id when not provided."""
        error = SchemaInvalidError("test")
        d = error.to_dict()
        assert "request_id" not in d

    def test_to_json_produces_valid_json(self):
        """to_json() produces valid JSON string."""
        error = IntegrityFailError(
            "Hash mismatch",
            details={"cell_id": "abc123", "position": 42}
        )
        json_str = error.to_json()
        parsed = json.loads(json_str)
        assert parsed["code"] == "DG_INTEGRITY_FAIL"
        assert parsed["message"] == "Hash mismatch"
        assert parsed["details"]["cell_id"] == "abc123"

    def test_to_json_with_indent(self):
        """to_json() accepts indent parameter."""
        error = SchemaInvalidError("test")
        json_str = error.to_json(indent=2)
        assert "\n" in json_str  # Pretty-printed has newlines

    def test_serialization_roundtrip(self):
        """Error can be serialized and deserialized."""
        error = UnauthorizedError(
            "Access denied",
            details={"namespace": "corp.hr", "permission": "write"},
            request_id="req_999"
        )
        json_str = error.to_json()
        parsed = json.loads(json_str)

        # Verify all fields preserved
        assert parsed["code"] == error.code
        assert parsed["message"] == error.message
        assert parsed["details"] == error.details
        assert parsed["request_id"] == error.request_id


class TestExceptionMapping:
    """Tests for EXCEPTION_MAP and wrap_internal_exception."""

    def test_integrity_violation_maps_to_integrity_fail(self):
        """IntegrityViolation maps to IntegrityFailError."""
        assert EXCEPTION_MAP[IntegrityViolation] == IntegrityFailError

    def test_chain_break_maps_to_integrity_fail(self):
        """ChainBreak maps to IntegrityFailError."""
        assert EXCEPTION_MAP[ChainBreak] == IntegrityFailError

    def test_temporal_violation_maps_to_integrity_fail(self):
        """TemporalViolation maps to IntegrityFailError."""
        assert EXCEPTION_MAP[TemporalViolation] == IntegrityFailError

    def test_graph_id_mismatch_maps_to_integrity_fail(self):
        """GraphIdMismatch maps to IntegrityFailError."""
        assert EXCEPTION_MAP[GraphIdMismatch] == IntegrityFailError

    def test_genesis_error_maps_to_schema_invalid(self):
        """GenesisError maps to SchemaInvalidError."""
        assert EXCEPTION_MAP[GenesisError] == SchemaInvalidError

    def test_genesis_validation_error_maps_to_schema_invalid(self):
        """GenesisValidationError maps to SchemaInvalidError."""
        assert EXCEPTION_MAP[GenesisValidationError] == SchemaInvalidError

    def test_access_denied_maps_to_unauthorized(self):
        """AccessDeniedError maps to UnauthorizedError."""
        assert EXCEPTION_MAP[AccessDeniedError] == UnauthorizedError

    def test_bridge_required_maps_to_unauthorized(self):
        """BridgeRequiredError maps to UnauthorizedError."""
        assert EXCEPTION_MAP[BridgeRequiredError] == UnauthorizedError

    def test_value_error_maps_to_input_invalid(self):
        """ValueError maps to InputInvalidError."""
        assert EXCEPTION_MAP[ValueError] == InputInvalidError

    def test_unknown_exception_maps_to_internal(self):
        """Unknown exceptions map to InternalError."""
        class CustomError(Exception):
            pass
        wrapped = wrap_internal_exception(CustomError("oops"))
        assert isinstance(wrapped, InternalError)
        assert wrapped.code == "DG_INTERNAL_ERROR"


class TestWrapInternalException:
    """Tests for wrap_internal_exception function."""

    def test_wraps_integrity_violation(self):
        """wrap_internal_exception wraps IntegrityViolation correctly."""
        exc = IntegrityViolation("Hash mismatch")
        wrapped = wrap_internal_exception(exc)
        assert isinstance(wrapped, IntegrityFailError)
        assert "Hash mismatch" in wrapped.message

    def test_preserves_original_message(self):
        """Original exception message is preserved."""
        exc = ChainBreak("Cell not found: abc123")
        wrapped = wrap_internal_exception(exc)
        assert wrapped.message == "Cell not found: abc123"

    def test_allows_message_override(self):
        """Message can be overridden."""
        exc = IntegrityViolation("internal message")
        wrapped = wrap_internal_exception(exc, default_message="public message")
        assert wrapped.message == "public message"

    def test_includes_internal_error_type(self):
        """Internal error type is included in details."""
        exc = TemporalViolation("timestamp error")
        wrapped = wrap_internal_exception(exc)
        assert wrapped.details["internal_error"] == "TemporalViolation"

    def test_merges_additional_details(self):
        """Additional details are merged in."""
        exc = IntegrityViolation("error")
        wrapped = wrap_internal_exception(exc, details={"cell_id": "abc", "position": 5})
        assert wrapped.details["cell_id"] == "abc"
        assert wrapped.details["position"] == 5
        assert wrapped.details["internal_error"] == "IntegrityViolation"

    def test_includes_request_id(self):
        """Request ID is passed through."""
        exc = AccessDeniedError("no access")
        wrapped = wrap_internal_exception(exc, request_id="req_xyz")
        assert wrapped.request_id == "req_xyz"

    def test_preserves_failed_checks_from_genesis_validation(self):
        """GenesisValidationError.failed_checks is preserved."""
        exc = GenesisValidationError("validation failed", ["check1", "check2"])
        wrapped = wrap_internal_exception(exc)
        assert wrapped.details["failed_checks"] == ["check1", "check2"]


class TestExceptionChaining:
    """Tests for exception chaining and traceback preservation."""

    def test_chaining_preserves_cause(self):
        """Exception chaining preserves __cause__."""
        try:
            try:
                raise IntegrityViolation("original error")
            except IntegrityViolation as e:
                raise wrap_internal_exception(e) from e
        except IntegrityFailError as wrapped:
            assert wrapped.__cause__ is not None
            assert isinstance(wrapped.__cause__, IntegrityViolation)

    def test_chained_exception_has_original_message(self):
        """Chained exception's __cause__ has original message."""
        try:
            try:
                raise ChainBreak("missing cell abc")
            except ChainBreak as e:
                raise wrap_internal_exception(e) from e
        except IntegrityFailError as wrapped:
            assert "missing cell abc" in str(wrapped.__cause__)

    def test_can_catch_by_base_class(self):
        """Wrapped exceptions can be caught by DecisionGraphError."""
        with pytest.raises(DecisionGraphError):
            exc = AccessDeniedError("denied")
            raise wrap_internal_exception(exc)

    def test_can_catch_by_specific_class(self):
        """Wrapped exceptions can be caught by specific class."""
        with pytest.raises(UnauthorizedError):
            exc = BridgeRequiredError("need bridge")
            raise wrap_internal_exception(exc)
```
  </action>
  <verify>
```bash
pytest tests/test_exceptions.py -v --tb=short
```
All tests should pass.
  </verify>
  <done>
- test_exceptions.py created with comprehensive tests
- All test classes and methods implemented
- Tests cover ERR-01 (base class attributes) and ERR-02 (exception mapping)
- Tests verify JSON serialization
- Tests verify exception chaining
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify all 69 original tests still pass</name>
  <files></files>
  <action>
Run the full test suite to verify the new exception module doesn't break existing functionality.

This is a verification task - no code changes needed.

If any tests fail, investigate and fix. The new exceptions module should be additive only - it should not modify any existing behavior.
  </action>
  <verify>
```bash
pytest tests/ -v --tb=short
```
Should show 69 original tests + new exception tests all passing.
  </verify>
  <done>
- Original 69 tests pass
- New exception tests pass
- No regressions introduced
  </done>
</task>

</tasks>

<verification>
```bash
# Run full test suite
pytest tests/ -v --tb=short

# Count tests to verify we have 69+ original plus new ones
pytest tests/ --collect-only -q | tail -5

# Specifically verify ERR-01 and ERR-02 requirements
pytest tests/test_exceptions.py -v -k "test_error_has_code or test_error_has_message or test_error_has_details or test_maps"
```
</verification>

<success_criteria>
1. All tests in test_exceptions.py pass
2. Original 69 tests remain passing (no regressions)
3. Test coverage includes:
   - ERR-01: Base class with .code, .message, .details
   - ERR-02: All exception mappings
   - JSON serialization (to_dict, to_json)
   - Exception chaining
4. Total test count >= 69 + 30 (approximately)
</success_criteria>

<output>
After completion, create `.planning/phases/01-error-foundation/01-03-SUMMARY.md`
</output>
