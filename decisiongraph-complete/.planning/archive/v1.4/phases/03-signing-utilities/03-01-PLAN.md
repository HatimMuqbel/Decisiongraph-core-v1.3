---
phase: 03-signing-utilities
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/decisiongraph/signing.py
  - src/decisiongraph/__init__.py
  - tests/test_signing.py
autonomous: true

must_haves:
  truths:
    - "sign_bytes() produces 64-byte Ed25519 signature from 32-byte private key"
    - "verify_signature() returns True for valid signature"
    - "verify_signature() returns False for tampered data (not exception)"
    - "Invalid key format raises DG_SIGNATURE_INVALID"
    - "Ed25519 signatures are deterministic (same input = same output)"
    - "All 281 existing tests remain passing"
  artifacts:
    - path: "src/decisiongraph/signing.py"
      provides: "Ed25519 sign/verify utilities"
      exports: ["sign_bytes", "verify_signature", "generate_ed25519_keypair"]
      min_lines: 80
    - path: "tests/test_signing.py"
      provides: "Comprehensive signing tests"
      contains: "class TestSigningUtilities"
      min_lines: 100
    - path: "pyproject.toml"
      provides: "cryptography dependency"
      contains: "cryptography>=46.0"
  key_links:
    - from: "src/decisiongraph/signing.py"
      to: "src/decisiongraph/exceptions.py"
      via: "import SignatureInvalidError"
      pattern: "from \\.exceptions import SignatureInvalidError"
    - from: "tests/test_signing.py"
      to: "src/decisiongraph/signing.py"
      via: "import signing utilities"
      pattern: "from decisiongraph\\.signing import"
---

<objective>
Implement Ed25519 signing and verification utilities for DecisionGraph.

Purpose: Provide cryptographic signing capabilities that will be used by the RFA layer (Phase 4) for cell signatures and ProofPacket signing.

Output:
- `signing.py` with `sign_bytes()`, `verify_signature()`, and `generate_ed25519_keypair()` functions
- Comprehensive test suite for signing utilities
- Updated pyproject.toml with cryptography dependency
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-signing-utilities/03-RESEARCH.md

# Key source files
@src/decisiongraph/exceptions.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cryptography dependency</name>
  <files>pyproject.toml</files>
  <action>
Add `cryptography>=46.0` as a required dependency to pyproject.toml.

In the `[project]` section, add a `dependencies` field (if not present) or append to existing:

```toml
dependencies = [
    "cryptography>=46.0",
]
```

This provides Ed25519 signing via the PyCA cryptography library with OpenSSL backend.
  </action>
  <verify>
Run `pip install -e .` to ensure the dependency is valid and installable.
Run `python -c "from cryptography.hazmat.primitives.asymmetric import ed25519; print('OK')"` to verify import works.
  </verify>
  <done>pyproject.toml contains cryptography>=46.0 dependency and pip install succeeds</done>
</task>

<task type="auto">
  <name>Task 2: Create signing.py with Ed25519 utilities</name>
  <files>src/decisiongraph/signing.py, src/decisiongraph/__init__.py</files>
  <action>
Create `src/decisiongraph/signing.py` with three functions:

1. **sign_bytes(private_key: bytes, data: bytes) -> bytes**
   - Accepts 32-byte Ed25519 private key seed and arbitrary data
   - Returns 64-byte Ed25519 signature
   - Raises SignatureInvalidError if private_key is not exactly 32 bytes
   - Uses `ed25519.Ed25519PrivateKey.from_private_bytes()`

2. **verify_signature(public_key: bytes, data: bytes, signature: bytes) -> bool**
   - Accepts 32-byte public key, data, and 64-byte signature
   - Returns True if signature is valid, False if verification fails
   - Raises SignatureInvalidError if:
     - public_key is not exactly 32 bytes
     - signature is not exactly 64 bytes
   - Uses `ed25519.Ed25519PublicKey.from_public_bytes()` and `key.verify()`
   - Catches `InvalidSignature` exception and returns False (verification failure is NOT exceptional)

3. **generate_ed25519_keypair() -> Tuple[bytes, bytes]**
   - Returns (private_key_bytes, public_key_bytes)
   - Both are 32 bytes raw format
   - Uses `Ed25519PrivateKey.generate()` for cryptographically secure random
   - For testing only (production keys managed externally)

Implementation notes from 03-RESEARCH.md:
- Import from `cryptography.hazmat.primitives.asymmetric import ed25519`
- Import from `cryptography.exceptions import InvalidSignature`
- Import `SignatureInvalidError` from `.exceptions`
- For key serialization, use `serialization.Encoding.Raw` and `serialization.PrivateFormat.Raw`
- Validate input lengths BEFORE calling cryptography library (clearer error messages)
- Ed25519 signatures are deterministic: same key + data = same signature

Add exports to `src/decisiongraph/__init__.py`:
- Add to imports: `from .signing import sign_bytes, verify_signature, generate_ed25519_keypair`
- Add to `__all__`: `'sign_bytes'`, `'verify_signature'`, `'generate_ed25519_keypair'`

Docstrings should include:
- Type annotations
- Docstrings with Args, Returns, Raises sections
- Note about Ed25519 determinism
- Examples (optional but helpful)
  </action>
  <verify>
Run `python -c "from decisiongraph import sign_bytes, verify_signature, generate_ed25519_keypair; print('Imports OK')"` to verify imports work.
  </verify>
  <done>signing.py exists with all three functions, imports work from decisiongraph package</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive signing tests</name>
  <files>tests/test_signing.py</files>
  <action>
Create `tests/test_signing.py` with comprehensive tests for Phase 3 requirements.

Test class structure:

```python
class TestSignBytes:
    """Tests for sign_bytes() - SIG-01"""

    def test_produces_64_byte_signature(self):
        """sign_bytes produces 64-byte Ed25519 signature"""

    def test_signing_is_deterministic(self):
        """Same key + data produces same signature (Ed25519 property)"""

    def test_different_data_produces_different_signature(self):
        """Different data produces different signature"""

    def test_different_key_produces_different_signature(self):
        """Different key produces different signature for same data"""

    def test_invalid_private_key_length_raises_error(self):
        """Private key not 32 bytes raises DG_SIGNATURE_INVALID"""

    def test_private_key_wrong_type_raises_error(self):
        """Non-bytes private key raises DG_SIGNATURE_INVALID"""


class TestVerifySignature:
    """Tests for verify_signature() - SIG-02"""

    def test_valid_signature_returns_true(self):
        """Valid signature returns True"""

    def test_tampered_data_returns_false(self):
        """Tampered data (1 byte changed) returns False, not exception"""

    def test_tampered_signature_returns_false(self):
        """Tampered signature returns False, not exception"""

    def test_wrong_key_returns_false(self):
        """Signature from different key returns False"""

    def test_invalid_public_key_length_raises_error(self):
        """Public key not 32 bytes raises DG_SIGNATURE_INVALID"""

    def test_invalid_signature_length_raises_error(self):
        """Signature not 64 bytes raises DG_SIGNATURE_INVALID"""

    def test_public_key_wrong_type_raises_error(self):
        """Non-bytes public key raises DG_SIGNATURE_INVALID"""


class TestGenerateKeypair:
    """Tests for generate_ed25519_keypair()"""

    def test_returns_tuple_of_two_bytes(self):
        """Returns tuple of (private_bytes, public_bytes)"""

    def test_private_key_is_32_bytes(self):
        """Private key is 32 bytes"""

    def test_public_key_is_32_bytes(self):
        """Public key is 32 bytes"""

    def test_each_call_produces_different_keys(self):
        """Each call generates new random keypair"""

    def test_generated_keys_work_with_sign_verify(self):
        """Generated keys can be used with sign_bytes and verify_signature"""


class TestSignatureErrorCodes:
    """Tests for error code correctness"""

    def test_error_code_is_dg_signature_invalid(self):
        """SignatureInvalidError has code DG_SIGNATURE_INVALID"""

    def test_error_includes_details(self):
        """Error includes helpful details dict"""
```

Test patterns from 03-RESEARCH.md:
- Use pytest.raises for exception testing
- Check error.code == "DG_SIGNATURE_INVALID"
- Tamper by XORing last byte: `signature[:-1] + bytes([signature[-1] ^ 0xFF])`
- Data tampering: change one character/byte
- Always verify 32-byte keys, 64-byte signatures

Run all tests including existing to ensure no regressions.
  </action>
  <verify>
Run `pytest tests/test_signing.py -v` to verify new tests pass.
Run `pytest tests/ -v` to verify all 281+ tests pass (no regressions).
  </verify>
  <done>test_signing.py exists with all test classes, all tests pass, total test count increases, no regressions</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Dependency check:**
   ```bash
   pip install -e . && python -c "from cryptography.hazmat.primitives.asymmetric import ed25519; print('cryptography OK')"
   ```

2. **Import check:**
   ```bash
   python -c "from decisiongraph import sign_bytes, verify_signature, generate_ed25519_keypair; print('All imports OK')"
   ```

3. **Quick functional check:**
   ```bash
   python -c "
   from decisiongraph import sign_bytes, verify_signature, generate_ed25519_keypair
   priv, pub = generate_ed25519_keypair()
   sig = sign_bytes(priv, b'hello')
   assert len(sig) == 64, 'Signature not 64 bytes'
   assert verify_signature(pub, b'hello', sig) is True, 'Valid sig failed'
   assert verify_signature(pub, b'tampered', sig) is False, 'Tampered data should fail'
   print('All functional checks passed')
   "
   ```

4. **Full test suite:**
   ```bash
   pytest tests/ -v --tb=short
   ```
   Expected: All tests pass, test count > 281 (new signing tests added)
</verification>

<success_criteria>
1. `pyproject.toml` contains `cryptography>=46.0` dependency
2. `signing.py` exports `sign_bytes`, `verify_signature`, `generate_ed25519_keypair`
3. `sign_bytes()` produces 64-byte deterministic Ed25519 signature
4. `verify_signature()` returns True for valid, False for invalid (no exception on verification failure)
5. Invalid key/signature format raises `SignatureInvalidError` with code `DG_SIGNATURE_INVALID`
6. All new signing tests pass
7. All 281 existing tests pass (no regressions)
8. SIG-01 and SIG-02 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/03-signing-utilities/03-01-SUMMARY.md` with:
- What was built (signing.py with Ed25519 utilities)
- Decisions made (cryptography library, raw bytes format, error handling strategy)
- Test count (new + total)
- Any deviations from plan
</output>
