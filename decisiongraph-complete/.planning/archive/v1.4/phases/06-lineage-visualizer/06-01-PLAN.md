---
phase: 06-lineage-visualizer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/decisiongraph/scholar.py
  - tests/test_lineage_visualizer.py
autonomous: true

must_haves:
  truths:
    - "to_audit_text() returns string containing decision, timestamp, supporting cells"
    - "Same QueryResult always produces identical audit text (deterministic)"
    - "to_dot() returns valid DOT syntax parseable by Graphviz"
    - "DOT output shows cell lineage with edges representing dependencies"
  artifacts:
    - path: "src/decisiongraph/scholar.py"
      provides: "to_audit_text() and to_dot() methods on QueryResult"
      contains: "def to_audit_text"
    - path: "src/decisiongraph/scholar.py"
      provides: "to_dot() method for Graphviz output"
      contains: "def to_dot"
    - path: "tests/test_lineage_visualizer.py"
      provides: "Comprehensive tests for VIS-01 and VIS-02"
      min_lines: 200
  key_links:
    - from: "QueryResult.to_audit_text()"
      to: "self.facts, self.authorization, self.resolution_events"
      via: "direct field access"
      pattern: "self\\.facts|self\\.authorization|self\\.resolution_events"
    - from: "QueryResult.to_dot()"
      to: "self.facts, self.candidates, self.bridges_used"
      via: "direct field access for node creation"
      pattern: "for.*in.*self\\.(facts|candidates|bridges_used)"
---

<objective>
Implement lineage visualization methods (to_audit_text and to_dot) on QueryResult class.

Purpose: Enable proof bundles to be exported as human-readable audit reports and Graphviz DOT graphs for visual lineage inspection.

Output: Two new methods on QueryResult class with comprehensive test coverage (~15-20 tests).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-lineage-visualizer/06-RESEARCH.md

# Source file to modify
@src/decisiongraph/scholar.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement to_audit_text() method on QueryResult</name>
  <files>src/decisiongraph/scholar.py</files>
  <action>
Add `to_audit_text()` method to the QueryResult class (after the existing `to_proof_bundle()` method around line 200).

Implementation requirements:
1. Returns deterministic plain text string
2. Include header: "DECISIONGRAPH AUDIT REPORT" with separator line
3. Query Information section: namespace_scope, requester_id, valid_time, system_time
4. Authorization section: status (ALLOWED/DENIED), reason, bridges_used (if any), bridge_effectiveness (if any)
5. Results section: fact count, list of fact cells with truncated cell_id (first 16 chars + "...")
6. Proof Details section: candidates_considered count, bridges_used count, conflicts_resolved count
7. Resolution Events section: numbered list with conflict_key, winner, reason, losers (if any)
8. Footer: Scholar version "1.3", Generated timestamp (use self.system_time for determinism)

Key implementation details:
- Use list.append() + "\n".join(lines) pattern for string building
- Truncate cell IDs to 16 chars + "..." for readability
- All iterations use already-sorted lists (facts, candidates, bridges_used, resolution_events are sorted in query_facts)
- Never add dynamic timestamps - use self.system_time for "Generated" field
- Include fact summary in cell listings: (subject predicate object[:20]...)
- Handle empty lists gracefully (don't print empty sections)

Docstring must include:
- Description of what the method generates
- Note about determinism guarantee
- Example usage showing saving to file
  </action>
  <verify>
Run: `python -c "from decisiongraph.scholar import QueryResult; print(hasattr(QueryResult, 'to_audit_text'))"`
Expected: True
  </verify>
  <done>
to_audit_text() method exists on QueryResult class and returns a multi-line string containing query info, authorization, results, proof details, and resolution events.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement to_dot() method on QueryResult</name>
  <files>src/decisiongraph/scholar.py</files>
  <action>
Add `to_dot()` method to the QueryResult class (after to_audit_text()).

Implementation requirements:
1. Returns valid Graphviz DOT syntax as string
2. Graph header: `digraph decision_lineage {` with comment, rankdir=TB, node defaults
3. Node types with colors:
   - Fact cells (winners): lightblue, label="Fact\n{subject}\n{predicate}"
   - Bridge cells: lightgreen, label="Bridge\n{cell_id[:12]}..."
   - Candidate cells (non-winners): lightgray, label="Candidate\n{subject}\n{predicate}"
4. Edge types with colors:
   - Authorization edges (fact -> bridge): green, label="authorized_by"
   - Resolution edges (winner -> loser): red, dashed, label="{resolution_reason}"
5. Graph footer: closing brace

Key implementation details:
- Add helper function `_escape_dot_string(s: str)` to escape quotes and backslashes: `s.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n')`
- Add helper function `_short_id(cell_id: str)` to truncate: `cell_id[:12] + "..."`
- Only create authorization edges if authorization.allowed is True and bridges_used is not empty
- Only create resolution edges for events where loser_cell_ids is not empty
- Iterate through facts, then bridges_used, then candidates (non-winners)
- Winner IDs determined by: `winner_ids = {f.cell_id for f in self.facts}`

Docstring must include:
- Description of what the method generates
- Note about DOT being renderable with `dot -Tpng` or online tools
- Note about determinism guarantee
- Example usage showing saving to file and rendering
  </action>
  <verify>
Run: `python -c "from decisiongraph.scholar import QueryResult; print(hasattr(QueryResult, 'to_dot'))"`
Expected: True
  </verify>
  <done>
to_dot() method exists on QueryResult class and returns valid DOT syntax containing nodes for facts/bridges/candidates and edges for authorization/resolution.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive test suite for lineage visualizer</name>
  <files>tests/test_lineage_visualizer.py</files>
  <action>
Create new test file `tests/test_lineage_visualizer.py` with comprehensive tests for VIS-01 and VIS-02.

Test structure (3 test classes, ~15-20 tests total):

**Class TestAuditText (VIS-01 tests):**
1. `test_to_audit_text_contains_header` - Report starts with "DECISIONGRAPH AUDIT REPORT"
2. `test_to_audit_text_contains_query_info` - Includes namespace, requester, timestamps
3. `test_to_audit_text_contains_authorization_allowed` - Shows "ALLOWED" and reason for authorized query
4. `test_to_audit_text_contains_authorization_denied` - Shows "DENIED" for unauthorized query
5. `test_to_audit_text_contains_results_with_facts` - Shows fact count and cell IDs
6. `test_to_audit_text_contains_resolution_events` - Shows conflict resolution details
7. `test_to_audit_text_deterministic` - Same QueryResult produces identical output on multiple calls
8. `test_to_audit_text_with_bridges` - Includes bridge information when bridges are used

**Class TestDOT (VIS-02 tests):**
1. `test_to_dot_valid_structure` - Output starts with "digraph" and ends with "}"
2. `test_to_dot_contains_node_definitions` - Has node [shape=box, style=filled]
3. `test_to_dot_contains_fact_nodes` - Facts appear as lightblue nodes
4. `test_to_dot_contains_candidate_nodes` - Non-winner candidates appear as lightgray nodes
5. `test_to_dot_contains_bridge_nodes` - Bridges appear as lightgreen nodes (when used)
6. `test_to_dot_contains_authorization_edges` - Fact->Bridge edges when authorized via bridge
7. `test_to_dot_contains_resolution_edges` - Winner->Loser edges for conflicts
8. `test_to_dot_escapes_special_chars` - Quotes and backslashes properly escaped
9. `test_to_dot_deterministic` - Same QueryResult produces identical DOT on multiple calls

**Class TestLineageVisualizerIntegration:**
1. `test_audit_text_and_dot_reflect_same_data` - Both methods reflect same proof_bundle
2. `test_empty_result_visualization` - Handles empty results (denied access) gracefully
3. `test_multiple_conflicts_visualization` - Complex scenario with multiple resolution events

Setup helper function needed:
- `create_test_scholar_with_facts()` - Creates chain with test facts for visualization
- Reuse patterns from existing test files (test_scholar.py, test_engine.py)

Import requirements:
```python
import pytest
from decisiongraph import (
    create_genesis_cell, Chain, DecisionCell, Fact, CellType,
    SourceQuality, create_scholar, Scholar
)
from decisiongraph.cell import get_current_timestamp
```
  </action>
  <verify>
Run: `cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_lineage_visualizer.py -v --tb=short`
Expected: All 15-20 tests pass
  </verify>
  <done>
Test file exists with comprehensive coverage of to_audit_text() and to_dot() methods, including determinism tests, edge cases (empty results, bridges, conflicts), and special character escaping.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Method existence:**
   ```bash
   python -c "from decisiongraph.scholar import QueryResult; r = QueryResult.__new__(QueryResult); print('to_audit_text:', hasattr(r, 'to_audit_text')); print('to_dot:', hasattr(r, 'to_dot'))"
   ```

2. **All tests pass:**
   ```bash
   cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest tests/test_lineage_visualizer.py -v
   ```

3. **Existing tests still pass:**
   ```bash
   cd /workspaces/Decisiongraph-core-v1.3/decisiongraph-complete && python -m pytest --tb=short -q
   ```
   Expected: 497+ tests pass (497 existing + ~15-20 new)

4. **Determinism check:**
   ```bash
   python -c "
from decisiongraph import create_genesis_cell, Chain, DecisionCell, Fact, CellType, SourceQuality, create_scholar
from decisiongraph.cell import get_current_timestamp
genesis = create_genesis_cell('test', 'test:admin')
chain = Chain(genesis)
# Add a fact
fact = Fact(namespace='test', subject='user:alice', predicate='has_role', object='admin', source_quality=SourceQuality.VERIFIED, confidence=1.0)
cell = DecisionCell.create(fact, chain.tip_hash, 'test:admin', CellType.FACT, get_current_timestamp())
chain.append(cell)
scholar = create_scholar(chain)
result = scholar.query_facts('test', 'test', requester_id='test:admin')
text1 = result.to_audit_text()
text2 = result.to_audit_text()
dot1 = result.to_dot()
dot2 = result.to_dot()
print('Audit text deterministic:', text1 == text2)
print('DOT deterministic:', dot1 == dot2)
"
   ```
   Expected: Both True
</verification>

<success_criteria>
1. to_audit_text() returns string containing decision, timestamp, and supporting cells
2. Same ProofBundle always produces identical audit text (deterministic)
3. to_dot() returns valid DOT syntax parseable by Graphviz (starts with "digraph", ends with "}")
4. DOT output shows cell lineage with edges representing dependencies
5. All 497 existing tests remain passing
6. ~15-20 new tests in test_lineage_visualizer.py all pass
7. VIS-01 and VIS-02 requirements complete
</success_criteria>

<output>
After completion, create `.planning/phases/06-lineage-visualizer/06-01-SUMMARY.md`
</output>
