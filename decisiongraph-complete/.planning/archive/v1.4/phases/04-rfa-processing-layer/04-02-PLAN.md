---
phase: 04-rfa-processing-layer
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/decisiongraph/engine.py
  - tests/test_engine.py
autonomous: true

must_haves:
  truths:
    - "ProofPacket can be signed by engine when signing_key provided"
    - "Signed ProofPacket includes signature with algorithm, public_key (base64), signature (base64)"
    - "verify_proof_packet() returns True for valid signature"
    - "verify_proof_packet() returns False for tampered proof_bundle"
    - "verify_proof_packet() returns False for wrong public key"
  artifacts:
    - path: "src/decisiongraph/engine.py"
      provides: "ProofPacket signing and verify_proof_packet() function"
      exports: ["verify_proof_packet"]
    - path: "tests/test_engine.py"
      provides: "Signature verification tests"
      contains: "TestEngineSignatures"
  key_links:
    - from: "src/decisiongraph/engine.py"
      to: "src/decisiongraph/signing.py"
      via: "sign_bytes, verify_signature"
      pattern: "sign_bytes|verify_signature"
---

<objective>
Implement ProofPacket signing (SIG-04) so that ProofPackets can be signed by the engine and verified by external parties.

Purpose: External verifiers can independently verify that a ProofPacket was issued by a trusted engine. This enables offline verification and audit trails.

Output:
- Updated `src/decisiongraph/engine.py` with signing implementation
- `verify_proof_packet()` function for external verification
- Updated tests covering signature scenarios
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-rfa-processing-layer/04-RESEARCH.md

# Prior plan summary (required - this plan depends on 04-01)
@.planning/phases/04-rfa-processing-layer/04-01-SUMMARY.md

# Relevant source files
@src/decisiongraph/engine.py
@src/decisiongraph/signing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ProofPacket signing in Engine</name>
  <files>src/decisiongraph/engine.py</files>
  <action>
Update `src/decisiongraph/engine.py` to implement ProofPacket signing:

1. **Add imports:**
```python
import base64
from .signing import sign_bytes, verify_signature
```

2. **Add _sign_proof_packet() method to Engine class:**
```python
def _sign_proof_packet(self, proof_packet: dict) -> dict:
    """
    Sign the ProofPacket's proof_bundle with Ed25519.

    Signs the canonical JSON bytes of proof_bundle.
    Adds signature object with algorithm, public_key, signature, signed_at.

    Returns:
        ProofPacket with signature field populated
    """
    if not self.signing_key or not self.public_key:
        return proof_packet  # Return unsigned

    # Canonicalize proof_bundle to bytes
    proof_bundle = proof_packet["proof_bundle"]
    canonical_bytes = json.dumps(
        proof_bundle, sort_keys=True, separators=(',', ':')
    ).encode('utf-8')

    # Sign using Phase 3 signing utilities
    signature_bytes = sign_bytes(self.signing_key, canonical_bytes)

    # Add signature object (base64 encoded for JSON safety)
    proof_packet["signature"] = {
        "algorithm": "Ed25519",
        "public_key": base64.b64encode(self.public_key).decode('ascii'),
        "signature": base64.b64encode(signature_bytes).decode('ascii'),
        "signed_at": get_current_timestamp()
    }

    return proof_packet
```

3. **Update process_rfa() to call _sign_proof_packet():**
After Step 6 (wrap in ProofPacket), add Step 7:
```python
# Step 7: Sign if key provided (SIG-04)
if self.signing_key:
    proof_packet = self._sign_proof_packet(proof_packet)

return proof_packet
```

4. **Add verify_proof_packet() function (module-level):**
```python
def verify_proof_packet(proof_packet: dict, engine_public_key: bytes) -> bool:
    """
    Verify a ProofPacket's signature.

    Reconstructs canonical bytes from proof_bundle and verifies
    the signature using the provided public key.

    Args:
        proof_packet: The packet returned by process_rfa()
        engine_public_key: Engine's Ed25519 public key (32 bytes)

    Returns:
        True if signature is valid, False if:
        - Packet is unsigned (signature is None)
        - Signature verification fails
        - public_key doesn't match

    Note: Does NOT raise exceptions for invalid signatures.
    Invalid signature is normal control flow (returns False).
    """
    # Check if packet is signed
    if not proof_packet.get("signature"):
        return False

    sig_info = proof_packet["signature"]

    # Decode signature from base64
    try:
        signature_bytes = base64.b64decode(sig_info["signature"])
    except Exception:
        return False

    # Reconstruct canonical bytes from proof_bundle
    proof_bundle = proof_packet["proof_bundle"]
    canonical_bytes = json.dumps(
        proof_bundle, sort_keys=True, separators=(',', ':')
    ).encode('utf-8')

    # Verify signature using Phase 3 utilities
    return verify_signature(engine_public_key, canonical_bytes, signature_bytes)
```

5. **Update __all__ to export verify_proof_packet:**
```python
__all__ = [
    'Engine',
    'process_rfa',
    'verify_proof_packet'
]
```
  </action>
  <verify>
Run `python -c "from decisiongraph.engine import Engine, process_rfa, verify_proof_packet; print('Import successful')"` - should print success message
  </verify>
  <done>
ProofPacket signing implemented in Engine. verify_proof_packet() function available for external verification.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add signature tests to test_engine.py</name>
  <files>tests/test_engine.py</files>
  <action>
Add a new test class `TestEngineSignatures` to `tests/test_engine.py`:

**1. Add imports at top:**
```python
from decisiongraph import generate_ed25519_keypair
from decisiongraph.engine import verify_proof_packet
```

**2. Add fixture for engine with signing key:**
```python
@pytest.fixture
def test_keypair():
    """Generate a test Ed25519 keypair."""
    return generate_ed25519_keypair()

@pytest.fixture
def test_engine_with_key(test_chain, test_keypair):
    """Engine with signing key."""
    priv, pub = test_keypair
    return Engine(test_chain, signing_key=priv, public_key=pub)
```

**3. Create TestEngineSignatures class with 6 tests:**

```python
class TestEngineSignatures:
    """Tests for SIG-04: ProofPacket signing and verification."""

    def test_process_rfa_signed_packet_when_key_provided(self, test_engine_with_key, valid_rfa):
        """ProofPacket.signature is populated when Engine has signing key."""
        packet = test_engine_with_key.process_rfa(valid_rfa)

        assert packet["signature"] is not None
        assert packet["signature"]["algorithm"] == "Ed25519"
        assert "public_key" in packet["signature"]
        assert "signature" in packet["signature"]
        assert "signed_at" in packet["signature"]

    def test_verify_proof_packet_valid_signature(self, test_engine_with_key, valid_rfa, test_keypair):
        """verify_proof_packet() returns True for valid signature."""
        _, pub = test_keypair
        packet = test_engine_with_key.process_rfa(valid_rfa)

        assert verify_proof_packet(packet, pub) is True

    def test_verify_proof_packet_tampered_data(self, test_engine_with_key, valid_rfa, test_keypair):
        """verify_proof_packet() returns False when proof_bundle tampered."""
        _, pub = test_keypair
        packet = test_engine_with_key.process_rfa(valid_rfa)

        # Tamper with proof_bundle
        packet["proof_bundle"]["tampered_field"] = "evil_value"

        assert verify_proof_packet(packet, pub) is False

    def test_verify_proof_packet_wrong_key(self, test_engine_with_key, valid_rfa):
        """verify_proof_packet() returns False with wrong public key."""
        packet = test_engine_with_key.process_rfa(valid_rfa)

        # Generate different keypair
        _, wrong_pub = generate_ed25519_keypair()

        assert verify_proof_packet(packet, wrong_pub) is False

    def test_verify_proof_packet_unsigned_packet(self, test_engine, valid_rfa, test_keypair):
        """verify_proof_packet() returns False for unsigned packet."""
        _, pub = test_keypair
        packet = test_engine.process_rfa(valid_rfa)

        # Packet is unsigned (Engine has no key)
        assert packet["signature"] is None
        assert verify_proof_packet(packet, pub) is False

    def test_verify_proof_packet_signature_base64_encoded(self, test_engine_with_key, valid_rfa):
        """Signature fields are base64 encoded strings (JSON-safe)."""
        packet = test_engine_with_key.process_rfa(valid_rfa)

        sig = packet["signature"]
        # Should be strings (base64), not bytes
        assert isinstance(sig["public_key"], str)
        assert isinstance(sig["signature"], str)
        # Should be valid base64
        import base64
        base64.b64decode(sig["public_key"])  # Should not raise
        base64.b64decode(sig["signature"])   # Should not raise
```
  </action>
  <verify>
Run `pytest tests/test_engine.py::TestEngineSignatures -v` - all 6 tests pass
  </verify>
  <done>
6 signature tests added covering: signed packet structure, valid verification, tampered data detection, wrong key detection, unsigned packet handling, base64 encoding.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update package exports and run full test suite</name>
  <files>src/decisiongraph/__init__.py</files>
  <action>
1. Update `src/decisiongraph/__init__.py`:

Update the engine import section:
```python
# Engine (v1.4)
from .engine import (
    Engine,
    process_rfa,
    verify_proof_packet
)
```

Update __all__ to include verify_proof_packet:
```python
    # Engine (v1.4)
    'Engine', 'process_rfa', 'verify_proof_packet',
```

2. Run full test suite:
- All existing tests must pass
- All new signature tests must pass

3. Verify external verification works from top-level import:
```python
from decisiongraph import Engine, process_rfa, verify_proof_packet, generate_ed25519_keypair
```
  </action>
  <verify>
Run `pytest --tb=short` - all tests pass (328+ tests including new signature tests)
  </verify>
  <done>
verify_proof_packet exported from package. Full test suite passes. SIG-04 requirement satisfied: ProofPacket can be signed by engine and verified by external parties.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from decisiongraph import Engine, verify_proof_packet"` succeeds
2. `pytest tests/test_engine.py::TestEngineSignatures -v` - all 6 tests pass
3. `pytest --tb=short` - all tests pass
4. ProofPacket from engine with signing key has populated signature field
5. verify_proof_packet returns True for untampered packet, False for tampered
</verification>

<success_criteria>
- ProofPacket can be signed by Engine when signing_key provided
- Signature uses base64 encoding (JSON-safe)
- verify_proof_packet() returns True for valid signature
- verify_proof_packet() returns False for tampered data
- verify_proof_packet() returns False for wrong public key
- verify_proof_packet() returns False for unsigned packet
- All existing tests pass
- SIG-04 requirement satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/04-rfa-processing-layer/04-02-SUMMARY.md`
</output>
